<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>zsh: 14 Expansion</title>

<meta name="description" content="zsh: 14 Expansion">
<meta name="keywords" content="zsh: 14 Expansion">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Expansion"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="Prompt-Expansion.html#Prompt-Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="Prompt-Expansion.html#Conditional-Substrings-in-Prompts" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#History-Expansion" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="Expansion-1"></a>
<h1 class="chapter">14 Expansion</h1>

<a name="index-expansion"></a>
<p>The following types of expansions are performed in the indicated order in
five steps:
</p>
<dl compact="compact">
<dt><em>History Expansion</em></dt>
<dd><p>This is performed only in interactive shells.
</p>
</dd>
<dt><em>Alias Expansion</em></dt>
<dd><p>Aliases are expanded immediately before the command line is parsed as
explained
in <a href="Shell-Grammar.html#Aliasing">Aliasing</a>.
</p>
</dd>
<dt><em>Process Substitution</em></dt>
<dt><em>Parameter Expansion</em></dt>
<dt><em>Command Substitution</em></dt>
<dt><em>Arithmetic Expansion</em></dt>
<dt><em>Brace Expansion</em></dt>
<dd><p>These five are performed in left-to-right fashion.  On each argument,
any of the five steps that are needed are performed one after the other.
Hence, for example, all the parts of parameter expansion are completed
before command substitution is started.  After these expansions, all
unquoted occurrences of the characters &lsquo;<tt>\</tt>&rsquo;,&lsquo;<tt>'</tt>&rsquo; and &lsquo;<tt>&quot;</tt>&rsquo; are
removed.
</p>
</dd>
<dt><em>Filename Expansion</em></dt>
<dd><p>If the <tt>SH_FILE_EXPANSION</tt> option is set, the order of expansion is
modified for compatibility with <cite>sh</cite> and <cite>ksh</cite>.  In that case
<em>filename expansion</em> is performed immediately after <em>alias expansion</em>,
preceding the set of five expansions mentioned above.
</p>
<a name="index-globbing"></a>
</dd>
<dt><em>Filename Generation</em></dt>
<dd><p>This expansion, commonly referred to as <cite>globbing</cite>, is always done last.
</p>
</dd>
</dl>

<p>The following sections explain the types of expansion in detail.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#History-Expansion">14.1 History Expansion</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Process-Substitution">14.2 Process Substitution</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Parameter-Expansion">14.3 Parameter Expansion</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Command-Substitution">14.4 Command Substitution</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Arithmetic-Expansion">14.5 Arithmetic Expansion</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Brace-Expansion">14.6 Brace Expansion</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Filename-Expansion">14.7 Filename Expansion</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Filename-Generation">14.8 Filename Generation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>
<hr>
<a name="History-Expansion"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expansion" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Overview" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="History-Expansion-1"></a>
<h2 class="section">14.1 History Expansion</h2>
<a name="index-history"></a>
<a name="index-history-expansion"></a>
<a name="index-expansion_002c-history"></a>
<p>History expansion allows you to use words from previous command
lines in the command line you are typing.  This simplifies spelling
corrections and the repetition of complicated commands or arguments.
</p>
<a name="index-HISTSIZE_002c-use-of"></a>
<p>Immediately before execution, each command is saved in the history list,
the size of which is controlled by the <tt>HISTSIZE</tt> parameter.  The one
most recent command is always retained in any case.  Each saved command in
the history list is called a history <em>event</em> and is assigned a number,
beginning with 1 (one) when the shell starts up.  The history number that
you may see in your prompt (see
<a href="Prompt-Expansion.html#Prompt-Expansion">Prompt Expansion</a>) is the number that is to be assigned to the <em>next</em> command.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Overview">14.1.1 Overview</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Event-Designators">14.1.2 Event Designators</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Word-Designators">14.1.3 Word Designators</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Modifiers">14.1.4 Modifiers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>
<hr>
<a name="Overview"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#History-Expansion" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#History-Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Event-Designators" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="Overview-1"></a>
<h3 class="subsection">14.1.1 Overview</h3>
<a name="index-histchars_002c-use-of-1"></a>
<p>A history expansion begins with the first character of the <tt>histchars</tt>
parameter, which is &lsquo;<tt>!</tt>&rsquo; by default, and may occur anywhere on the
command line; history expansions do not nest.  The &lsquo;<tt>!</tt>&rsquo; can be escaped
with &lsquo;<tt>\</tt>&rsquo; or can be enclosed between a pair of single quotes (<tt>''</tt>)
to suppress its special meaning.  Double quotes will <em>not</em> work for
this.  Following this history character is an optional event designator
(<a href="#Event-Designators">Event Designators</a>) and then an optional word
designator (<a href="#Word-Designators">Word Designators</a>); if neither of these designators is
present, no history expansion occurs.
</p>
<p>Input lines containing history expansions are echoed after being expanded,
but before any other expansions take place and before the command is
executed.  It is this expanded form that is recorded as the history event
for later references.
</p>
<p>By default, a history reference with no event designator refers to the
same event as any preceding history reference on that command line; if it
is the only history reference in a command, it refers to the previous
command.
<a name="index-CSH_005fJUNKIE_005fHISTORY_002c-use-of"></a>
However, if the option <tt>CSH_JUNKIE_HISTORY</tt> is set, then every history
reference with no event specification <em>always</em> refers to the previous
command.
</p>
<p>For example, &lsquo;<tt>!</tt>&rsquo; is the event designator for the previous command, so
&lsquo;<tt>!!:1</tt>&rsquo; always refers to the first word of the previous command, and
&lsquo;<tt>!!$</tt>&rsquo; always refers to the last word of the previous command.  With
<tt>CSH_JUNKIE_HISTORY</tt> set, then &lsquo;<tt>!:1</tt>&rsquo; and &lsquo;<tt>!$</tt>&rsquo; function in the
same manner as &lsquo;<tt>!!:1</tt>&rsquo; and &lsquo;<tt>!!$</tt>&rsquo;, respectively.  Conversely, if
<tt>CSH_JUNKIE_HISTORY</tt> is unset, then &lsquo;<tt>!:1</tt>&rsquo; and &lsquo;<tt>!$</tt>&rsquo; refer to the
first and last words, respectively, of the same event referenced by the
nearest other history reference preceding them on the current command
line, or to the previous command if there is no preceding reference.
</p>
<p>The character sequence &lsquo;<tt>^</tt><var>foo</var><tt>^</tt><var>bar</var>&rsquo; (where &lsquo;<tt>^</tt>&rsquo; is
actually the second character of the <tt>histchars</tt> parameter)
repeats the last command, replacing the string <var>foo</var> with <var>bar</var>.
More precisely, the sequence &lsquo;<tt>^</tt><var>foo</var><tt>^</tt><var>bar</var><tt>^</tt>&rsquo; is
synonymous with &lsquo;<tt>!!:s</tt><tt>^</tt><var>foo</var><tt>^</tt><var>bar</var><tt>^</tt>&rsquo;, hence other
modifiers (see <a href="#Modifiers">Modifiers</a>) may follow the final &lsquo;<tt>^</tt>&rsquo;.
In particular, &lsquo;<tt>^</tt><var>foo</var><tt>^</tt><var>bar</var><tt>^:G</tt>&rsquo; performs a global
substitution.
</p>
<p>If the shell encounters the character sequence &lsquo;<tt>!&quot;</tt>&rsquo;
in the input, the history mechanism is temporarily disabled until
the current list (see
<a href="Shell-Grammar.html#Shell-Grammar">Shell Grammar</a>) is fully parsed.  The &lsquo;<tt>!&quot;</tt>&rsquo; is removed from the input, and any
subsequent &lsquo;<tt>!</tt>&rsquo; characters have no special significance.
</p>
<a name="index-fc_002c-use-of"></a>
<p>A less convenient but more comprehensible form of command history support
is provided by the <tt>fc</tt> builtin.
</p><hr>
<a name="Event-Designators"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Overview" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#History-Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Word-Designators" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="Event-Designators-1"></a>
<h3 class="subsection">14.1.2 Event Designators</h3>
<a name="index-history-event-designators"></a>
<a name="index-event-designators_002c-history"></a>
<p>An event designator is a reference to a command-line entry in the history
list.  In the list below, remember that the initial <tt>`!'</tt> in each item
may be changed to another character by setting the <tt>histchars</tt>
parameter.
</p>
<dl compact="compact">
<dt><tt>!</tt></dt>
<dd><p>Start a history expansion, except when followed by a blank, newline,
&lsquo;<tt>=</tt>&rsquo; or &lsquo;<tt>(</tt>&rsquo;.  If followed immediately by a word designator
(<a href="#Word-Designators">Word Designators</a>), this forms a history reference
with no event designator (<a href="#Overview">Overview</a>).
</p>
</dd>
<dt><tt>!!</tt></dt>
<dd><p>Refer to the previous command.
By itself, this expansion
repeats the previous command.
</p>
</dd>
<dt><tt>!</tt><var>n</var></dt>
<dd><p>Refer to command-line <var>n</var>.
</p>
</dd>
<dt><tt>!-</tt><var>n</var></dt>
<dd><p>Refer to the current command-line minus <var>n</var>.
</p>
</dd>
<dt><tt>!</tt><var>str</var></dt>
<dd><p>Refer to the most recent command starting with <var>str</var>.
</p>
</dd>
<dt><tt>!?</tt><var>str</var>[<tt>?</tt>]</dt>
<dd><p>Refer to the most recent command containing <var>str</var>.  The trailing
&lsquo;<tt>?</tt>&rsquo; is necessary if this reference is to be followed by a modifier or
followed by any text that is not to be considered part of <var>str</var>.
</p>
</dd>
<dt><tt>!#</tt></dt>
<dd><p>Refer to the current command line typed in so far.  The line is
treated as if it were complete up to and including the word before the
one with the &lsquo;<tt>!#</tt>&rsquo; reference.
</p>
</dd>
<dt><tt>!{</tt>...<tt>}</tt></dt>
<dd><p>Insulate a history reference from adjacent characters (if necessary).
</p>
</dd>
</dl>
<hr>
<a name="Word-Designators"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Event-Designators" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#History-Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Modifiers" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="Word-Designators-1"></a>
<h3 class="subsection">14.1.3 Word Designators</h3>
<a name="index-history-word-designators"></a>
<a name="index-word-designators_002c-history"></a>
<p>A word designator indicates which word or words of a given command line are
to be included in a history reference.  A &lsquo;<tt>:</tt>&rsquo; usually
separates the event specification from the word designator.
It may be omitted only if the word designator begins with a
&lsquo;<tt>^</tt>&rsquo;, &lsquo;<tt>$</tt>&rsquo;, &lsquo;<tt>*</tt>&rsquo;, &lsquo;<tt>-</tt>&rsquo; or &lsquo;<tt>%</tt>&rsquo;.
Word designators include:
</p>
<dl compact="compact">
<dt><tt>0</tt></dt>
<dd><p>The first input word (command).
</p></dd>
<dt><var>n</var></dt>
<dd><p>The <var>n</var>th argument.
</p></dd>
<dt><tt>^</tt></dt>
<dd><p>The first argument.  That is, <tt>1</tt>.
</p></dd>
<dt><tt>$</tt></dt>
<dd><p>The last argument.
</p></dd>
<dt><tt>%</tt></dt>
<dd><p>The word matched by (the most recent) <tt>?</tt><var>str</var> search.
</p></dd>
<dt><var>x</var><tt>-</tt><var>y</var></dt>
<dd><p>A range of words; <var>x</var> defaults to <tt>0</tt>.
</p></dd>
<dt><tt>*</tt></dt>
<dd><p>All the arguments, or a null value if there are none.
</p></dd>
<dt><var>x</var><tt>*</tt></dt>
<dd><p>Abbreviates &lsquo;<var>x</var><tt>-$</tt>&rsquo;.
</p></dd>
<dt><var>x</var><tt>-</tt></dt>
<dd><p>Like &lsquo;<var>x</var><tt>*</tt>&rsquo; but omitting word <tt>$</tt>.
</p></dd>
</dl>

<p>Note that a &lsquo;<tt>%</tt>&rsquo; word designator works only when used in one of
&lsquo;<tt>!%</tt>&rsquo;, &lsquo;<tt>!:%</tt>&rsquo; or &lsquo;<tt>!?</tt><var>str</var><tt>?:%</tt>&rsquo;, and only when used after a
<tt>!?</tt> expansion (possibly in an earlier command).  Anything else results
in an error, although the error may not be the most obvious one.
</p><hr>
<a name="Modifiers"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Word-Designators" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#History-Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Process-Substitution" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="Modifiers-1"></a>
<h3 class="subsection">14.1.4 Modifiers</h3>
<a name="index-modifiers"></a>
<a name="index-colon-modifiers"></a>
<a name="index-history-modifiers"></a>
<a name="index-globbing-modifiers"></a>
<a name="index-parameter-modifiers"></a>
<p>After the optional word designator, you can add
a sequence of one or more of the following modifiers,
each preceded by a &lsquo;<tt>:</tt>&rsquo;.  These modifiers also work on the result
of <em>filename generation</em> and <em>parameter expansion</em>, except where
noted.
</p>
<dl compact="compact">
<dt><tt>a</tt></dt>
<dd><p>Turn a file name into an absolute path:  prepends the current directory,
if necessary; remove &lsquo;<tt>.</tt>&rsquo; path segments; and remove &lsquo;<tt>..</tt>&rsquo; path segments
and the segments that immediately precede them.
</p>
<p>This transformation is agnostic about what is in the filesystem, i.e. is
on the logical, not the physical directory.  It takes place in the same
manner as when changing directories when neither of the options
<tt>CHASE_DOTS</tt> or <tt>CHASE_LINKS</tt> is set.  For example,
&lsquo;<tt>/before/here/../after</tt>&rsquo; is always transformed to
&lsquo;<tt>/before/after</tt>&rsquo;, regardless of whether &lsquo;<tt>/before/here</tt>&rsquo; exists or what
kind of object (dir, file, symlink, etc.) it is.
</p>
</dd>
<dt><tt>A</tt></dt>
<dd><p>Turn a file name into an absolute path as the &lsquo;<tt>a</tt>&rsquo; modifier does, and
<em>then</em> pass the result through the <tt>realpath(3)</tt> library
function to resolve symbolic links.
</p>
<p>Note: on systems that do not have a <tt>realpath(3)</tt> library
function, symbolic links are not resolved, so on those systems &lsquo;<tt>a</tt>&rsquo; and
&lsquo;<tt>A</tt>&rsquo; are equivalent.
</p>
<p>Note: <tt>foo:A</tt> and <tt>realpath(foo)</tt> are different on some inputs.
For <tt>realpath(foo)</tt> semantics, see the &lsquo;<tt>P</tt>&lsquo; modifier.
</p>
</dd>
<dt><tt>c</tt></dt>
<dd><p>Resolve a command name into an absolute path by searching the command
path given by the <tt>PATH</tt> variable.  This does not work for commands
containing directory parts.  Note also that this does not usually work as
a glob qualifier unless a file of the same name is found in the
current directory.
</p>
</dd>
<dt><tt>e</tt></dt>
<dd><p>Remove all but the part of the filename extension following the &lsquo;<tt>.</tt>&rsquo;;
see the definition of the filename extension in the description of the
<tt>r</tt> modifier below.  Note that according to that definition the result
will be empty if the string ends with a &lsquo;<tt>.</tt>&rsquo;.
</p>
</dd>
<dt><tt>h</tt></dt>
<dd><p>Remove a trailing pathname component, leaving the head.  This works
like &lsquo;<tt>dirname</tt>&rsquo;.
</p>
</dd>
<dt><tt>l</tt></dt>
<dd><p>Convert the words to all lowercase.
</p>
</dd>
<dt><tt>p</tt></dt>
<dd><p>Print the new command but do not execute it.  Only works with history
expansion.
</p>
</dd>
<dt><tt>P</tt></dt>
<dd><p>Turn a file name into an absolute path, like <tt>realpath(3)</tt>.
The resulting path will be absolute, have neither &lsquo;<tt>.</tt>&rsquo; nor &lsquo;<tt>..</tt>&rsquo; components,
and refer to the same directory entry as the input filename.
</p>
<p>Unlike <tt>realpath(3)</tt>, non-existent trailing components are
permitted and preserved.
</p>
</dd>
<dt><tt>q</tt></dt>
<dd><p>Quote the substituted words, escaping further substitutions.  Works
with history expansion and parameter expansion, though for parameters
it is only useful if the resulting text is to be re-evaluated such as
by <tt>eval</tt>.
</p>
</dd>
<dt><tt>Q</tt></dt>
<dd><p>Remove one level of quotes from the substituted words.
</p>
</dd>
<dt><tt>r</tt></dt>
<dd><p>Remove a filename extension leaving the root name.  Strings with no
filename extension are not altered.  A filename
extension is a &lsquo;<tt>.</tt>&rsquo; followed by any number of characters (including
zero) that are neither &lsquo;<tt>.</tt>&rsquo; nor &lsquo;<tt>/</tt>&rsquo; and that continue to the end
of the string.  For example, the extension of
&lsquo;<tt>foo.orig.c</tt>&rsquo; is &lsquo;<tt>.c</tt>&rsquo;, and &lsquo;<tt>dir.c/foo</tt>&rsquo; has no extension.
</p>
</dd>
<dt><tt>s/</tt><var>l</var><tt>/</tt><var>r</var>[<tt>/</tt>]</dt>
<dd><p>Substitute <var>r</var> for <var>l</var> as described below.
The substitution is done only for the
first string that matches <var>l</var>.  For arrays and for filename
generation, this applies to each word of the expanded text.  See
below for further notes on substitutions.
</p>
<p>The forms &lsquo;<tt>gs/</tt><var>l</var><tt>/</tt><var>r</var>&rsquo; and &lsquo;<tt>s/</tt><var>l</var><tt>/</tt><var>r</var><tt>/:G</tt>&rsquo;
perform global substitution, i.e. substitute every occurrence of <var>r</var>
for <var>l</var>.  Note that the <tt>g</tt> or <tt>:G</tt> must appear in exactly the
position shown.
</p>
<p>See further notes on this form of substitution below.
</p>
</dd>
<dt><tt>&amp;</tt></dt>
<dd><p>Repeat the previous <tt>s</tt> substitution.  Like <tt>s</tt>, may be preceded
immediately by a <tt>g</tt>.  In parameter expansion the <tt>&amp;</tt> must appear
inside braces, and in filename generation it must be quoted with a
backslash.
</p>
</dd>
<dt><tt>t</tt></dt>
<dd><p>Remove all leading pathname components, leaving the tail.  This works
like &lsquo;<tt>basename</tt>&rsquo;.
</p>
</dd>
<dt><tt>u</tt></dt>
<dd><p>Convert the words to all uppercase.
</p>
</dd>
<dt><tt>x</tt></dt>
<dd><p>Like <tt>q</tt>, but break into words at whitespace.  Does not work with
parameter expansion.
</p>
</dd>
</dl>

<p>The <tt>s/</tt><var>l</var><tt>/</tt><var>r</var><tt>/</tt> substitution works as follows.  By
default the left-hand side of substitutions are not patterns, but
character strings.  Any character can be used as the delimiter in place
of &lsquo;<tt>/</tt>&rsquo;.  A backslash quotes the delimiter character.  The character
&lsquo;<tt>&amp;</tt>&rsquo;, in the right-hand-side <var>r</var>, is replaced by the text from the
left-hand-side <var>l</var>.  The &lsquo;<tt>&amp;</tt>&rsquo; can be quoted with a backslash.  A
null <var>l</var> uses the previous string either from the previous <var>l</var> or
from the contextual scan string <var>s</var> from &lsquo;<tt>!?</tt><var>s</var>&rsquo;.  You can
omit the rightmost delimiter if a newline immediately follows <var>r</var>;
the rightmost &lsquo;<tt>?</tt>&rsquo; in a context scan can similarly be omitted.  Note
the same record of the last <var>l</var> and <var>r</var> is maintained across all
forms of expansion.
</p>
<p>Note that if a &lsquo;<tt>&amp;</tt>&rsquo; is used within glob qualifiers an extra backslash
is needed as a <tt>&amp;</tt> is a special character in this case.
</p>
<p>Also note that the order of expansions affects the interpretation of
<var>l</var> and <var>r</var>.  When used in a history expansion, which occurs before
any other expansions, <var>l</var> and <var>r</var> are treated as literal strings
(except as explained for <tt>HIST_SUBST_PATTERN</tt> below).  When used in
parameter expansion, the replacement of <var>r</var> into the parameter&rsquo;s value
is done first, and then any additional process, parameter, command,
arithmetic, or brace references are applied, which may evaluate those
substitutions and expansions more than once if <var>l</var> appears more than
once in the starting value.  When used in a glob qualifier, any
substitutions or expansions are performed once at the time the qualifier
is parsed, even before the &lsquo;<tt>:s</tt>&rsquo; expression itself is divided into
<var>l</var> and <var>r</var> sides.
</p>
<p>If the option <tt>HIST_SUBST_PATTERN</tt> is set, <var>l</var> is treated as
a pattern of the usual form described in
<a href="#Filename-Generation">Filename Generation</a>.  This can be used in
all the places where modifiers are available; note, however, that
in globbing qualifiers parameter substitution has already taken place,
so parameters in the replacement string should be quoted to ensure
they are replaced at the correct time.
Note also that complicated patterns used in globbing qualifiers may
need the extended glob qualifier notation
<tt>(#q:s/</tt><var>...</var><tt>/</tt><var>...</var><tt>/)</tt> in order for the
shell to recognize the expression as a glob qualifier.  Further,
note that bad patterns in the substitution are not subject to
the <tt>NO_BAD_PATTERN</tt> option so will cause an error.
</p>
<p>When <tt>HIST_SUBST_PATTERN</tt> is set, <var>l</var> may start with a <tt>#</tt>
to indicate that the pattern must match at the start of the string
to be substituted, and a <tt>%</tt> may appear at the start or after an <tt>#</tt>
to indicate that the pattern must match at the end of the string
to be substituted.  The <tt>%</tt> or <tt>#</tt> may be quoted with two
backslashes.
</p>
<p>For example, the following piece of filename generation code
with the <tt>EXTENDED_GLOB</tt> option:
</p>
<div class="example">
<pre class="example">print *.c(#q:s/#%(#b)s(*).c/'S${match[1]}.C'/)
</pre></div>

<p>takes the expansion of <tt>*.c</tt> and applies the glob qualifiers in the
<tt>(#q</tt><var>...</var><tt>)</tt> expression, which consists of a substitution
modifier anchored to the start and end of each word (<tt>#%</tt>).  This
turns on backreferences (<tt>(#b)</tt>), so that the parenthesised
subexpression is available in the replacement string as <tt>${match[1]}</tt>.
The replacement string is quoted so that the parameter is not substituted
before the start of filename generation.
</p>
<p>The following <tt>f</tt>, <tt>F</tt>, <tt>w</tt> and <tt>W</tt> modifiers work only with
parameter expansion and filename generation.  They are listed here to
provide a single point of reference for all modifiers.
</p>
<dl compact="compact">
<dt><tt>f</tt></dt>
<dd><p>Repeats the immediately (without a colon) following modifier until the
resulting word doesn&rsquo;t change any more.
</p>
</dd>
<dt><tt>F:</tt><var>expr</var><tt>:</tt></dt>
<dd><p>Like <tt>f</tt>, but repeats only <var>n</var> times if the expression
<var>expr</var> evaluates to <var>n</var>.  Any character can be used instead of
the &lsquo;<tt>:</tt>&rsquo;; if &lsquo;<tt>(</tt>&rsquo;, &lsquo;<tt>[</tt>&rsquo;, or &lsquo;<tt>{</tt>&rsquo;
is used as the opening delimiter,
the closing delimiter should be &rsquo;<tt>)</tt>&rsquo;, &lsquo;<tt>]</tt>&rsquo;, or &lsquo;<tt>}</tt>&rsquo;,
respectively.
</p>
</dd>
<dt><tt>w</tt></dt>
<dd><p>Makes the immediately following modifier work on each word in the
string.
</p>
</dd>
<dt><tt>W:</tt><var>sep</var><tt>:</tt></dt>
<dd><p>Like <tt>w</tt> but words are considered to be the parts of the string
that are separated by <var>sep</var>. Any character can be used instead of
the &lsquo;<tt>:</tt>&rsquo;; opening parentheses are handled specially, see above.
</p>
</dd>
</dl>
<hr>
<a name="Process-Substitution"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Modifiers" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Parameter-Expansion" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="Process-Substitution-1"></a>
<h2 class="section">14.2 Process Substitution</h2>
<a name="index-process-substitution"></a>
<a name="index-substitution_002c-process"></a>
<p>Each part of a command argument that takes the form
&lsquo;<tt>&lt;(</tt><var>list</var><tt>)</tt>&rsquo;,
&lsquo;<tt>&gt;(</tt><var>list</var><tt>)</tt>&rsquo; or
&lsquo;<tt>=(</tt><var>list</var><tt>)</tt>&rsquo;
is subject to process substitution.  The expression may be preceded
or followed by other strings except that, to prevent clashes with
commonly occurring strings and patterns, the last
form must occur at the start of a command argument, and the forms
are only expanded when first parsing command or assignment arguments.
Process substitutions may be used following redirection operators; in this
case, the substitution must appear with no trailing string.
</p>
<p>Note that &lsquo;<tt>&lt;&lt;(</tt><var>list</var><tt>)</tt>&rsquo; is not a special syntax; it
is equivalent to &lsquo;<tt>&lt; &lt;(</tt><var>list</var><tt>)</tt>&rsquo;, redirecting
standard input from the result of process substitution.  Hence all
the following documentation applies.  The second form (with the space)
is recommended for clarity.
</p>
<p>In the case of the <tt>&lt;</tt> or <tt>&gt;</tt> forms, the shell runs the commands in
<var>list</var> as a subprocess of the job executing the shell command line.
If the system supports the <tt>/dev/fd</tt>
mechanism, the command argument is the name of the device file
corresponding to a file descriptor; otherwise, if the system supports named
pipes (FIFOs), the command argument will be a named pipe.  If the form with
<tt>&gt;</tt> is selected then writing on this special file will provide input for
<var>list</var>.  If <tt>&lt;</tt> is used, then the file passed as an argument will
be connected to the output of the <var>list</var> process.  For example,
</p>
<div class="example">
<pre class="example"><tt>paste &lt;(cut -f1</tt> <var>file1</var><tt>) &lt;(cut -f3</tt> <var>file2</var><tt>) |
tee &gt;(</tt><var>process1</var><tt>) &gt;(</tt><var>process2</var><tt>) &gt;/dev/null</tt>
</pre></div>

<p>cuts fields 1 and 3 from the files <var>file1</var> and <var>file2</var> respectively,
pastes the results together, and sends it to the processes
<var>process1</var> and <var>process2</var>.
</p>
<p>If <tt>=(</tt><var>...</var><tt>)</tt> is used instead of
<tt>&lt;(</tt><var>...</var><tt>)</tt>,
then the file passed as an argument will be the name
of a temporary file containing the output of the <var>list</var>
process.  This may be used instead of the <tt>&lt;</tt>
form for a program that expects to lseek (see man page lseek(2))
on the input file.
</p>
<p>There is an optimisation for substitutions of the form
<tt>=(&lt;&lt;&lt;</tt><var>arg</var><tt>)</tt>, where <var>arg</var> is a single-word argument
to the here-string redirection <tt>&lt;&lt;&lt;</tt>.  This form produces a file name
containing the value of <var>arg</var> after any substitutions have been
performed.  This is handled entirely within the current shell.  This is
effectively the reverse of the special form <tt>$(&lt;</tt><var>arg</var><tt>)</tt>
which treats <var>arg</var> as a file name and replaces it with the file&rsquo;s
contents.
</p>
<p>The <tt>=</tt> form is useful as both the <tt>/dev/fd</tt> and the named pipe
implementation of <tt>&lt;(</tt><var>...</var><tt>)</tt> have drawbacks.  In 
the former case, some programmes may automatically close the file
descriptor in question before examining the file on the command line,
particularly if this is necessary for security reasons such as when the
programme is running setuid.  In the second case, if the
programme does not actually open the file, the subshell attempting to read
from or write to the pipe will (in a typical implementation, different
operating systems may have different behaviour) block for ever and have to
be killed explicitly.  In both cases, the shell actually supplies the
information using a pipe, so that programmes that expect to lseek
(see man page lseek(2)) on the file will not work.
</p>
<p>Also note that the previous example can be more compactly and
efficiently written (provided the <tt>MULTIOS</tt> option is set) as:
</p>
<div class="example">
<pre class="example"><tt>paste &lt;(cut -f1</tt> <var>file1</var><tt>) &lt;(cut -f3</tt> <var>file2</var><tt>)</tt> <tt>&gt; &gt;(</tt><var>process1</var><tt>) &gt; &gt;(</tt><var>process2</var><tt>)</tt>
</pre></div>

<p>The shell uses pipes instead of FIFOs to implement the latter
two process substitutions in the above example.
</p>
<p>There is an additional problem with <tt>&gt;(</tt><var>process</var><tt>)</tt>; when
this is attached to an external command, the parent shell does not wait
for <var>process</var> to finish and hence an immediately following command
cannot rely on the results being complete.  The problem and solution are
the same as described in the section <em>MULTIOS</em> in
<a href="Redirection.html#Redirection">Redirection</a>.  Hence in a simplified
version of the example above:
</p>
<div class="example">
<pre class="example"><tt>paste &lt;(cut -f1</tt> <var>file1</var><tt>) &lt;(cut -f3</tt> <var>file2</var><tt>)</tt> <tt>&gt; &gt;(</tt><var>process</var><tt>)</tt>
</pre></div>

<p>(note that no <tt>MULTIOS</tt> are involved), <var>process</var> will be run
asynchronously as far as the parent shell is concerned.  The workaround is:
</p>
<div class="example">
<pre class="example"><tt>{ paste &lt;(cut -f1</tt> <var>file1</var><tt>) &lt;(cut -f3</tt> <var>file2</var><tt>) }</tt> <tt>&gt; &gt;(</tt><var>process</var><tt>)</tt>
</pre></div>

<p>The extra processes here are
spawned from the parent shell which will wait for their completion.
</p>
<p>Another problem arises any time a job with a substitution that requires
a temporary file is disowned by the shell, including the case where
&lsquo;<tt>&amp;!</tt>&rsquo; or &lsquo;<tt>&amp;|</tt>&rsquo; appears at the end of a command containing a
substitution.  In that case the temporary file will not be cleaned up as
the shell no longer has any memory of the job.  A workaround is to use
a subshell, for example,
</p>
<div class="example">
<pre class="example">(mycmd =(myoutput)) &amp;!
</pre></div>

<p>as the forked subshell will wait for the command to finish then remove
the temporary file.
</p>
<p>A general workaround to ensure a process substitution endures for
an appropriate length of time is to pass it as a parameter to
an anonymous shell function (a piece of shell code that is run
immediately with function scope).  For example, this code:
</p>
<div class="example">
<pre class="example">() {
   print File $1:
   cat $1
} =(print This be the verse)
</pre></div>

<p>outputs something resembling the following
</p>
<div class="example">
<pre class="example">File /tmp/zsh6nU0kS:
This be the verse
</pre></div>

<p>The temporary file created by the process substitution will be deleted
when the function exits.
</p>
<hr>
<a name="Parameter-Expansion"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Process-Substitution" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Parameter-Expansion-Flags" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="Parameter-Expansion-1"></a>
<h2 class="section">14.3 Parameter Expansion</h2>
<a name="index-parameter-expansion"></a>
<a name="index-expansion_002c-parameter"></a>
<p>The character &lsquo;<tt>$</tt>&rsquo; is used to introduce parameter expansions.
See
<a href="Parameters.html#Parameters">Parameters</a>
for a description of parameters, including arrays, associative arrays,
and subscript notation to access individual array elements.
</p>
<p>Note in particular the fact that words of unquoted parameters are not
automatically split on whitespace unless the option <tt>SH_WORD_SPLIT</tt> is
set; see references to this option below for more details.  This is an
important difference from other shells.
</p>
<p>In the expansions discussed below that require a pattern, the form of
the pattern is the same as that used for filename generation;
see <a href="#Filename-Generation">Filename Generation</a>.  Note that these patterns, along with
the replacement text of any substitutions, are themselves subject to
parameter expansion, command substitution, and arithmetic expansion.
In addition to the following operations, the colon modifiers described in
<a href="#Modifiers">Modifiers</a> in <a href="#History-Expansion">History Expansion</a> can be
applied:  for example, <tt>${i:s/foo/bar/}</tt> performs string
substitution on the expansion of parameter <tt>$i</tt>.
</p>
<p>In the following descriptions, &lsquo;word&rsquo; refers to a single word
substituted on the command line, not necessarily a space delimited word.
With default options, after the assignments:
</p>
<div class="example">
<pre class="example">array=(&quot;first word&quot; &quot;second word&quot;)
scalar=&quot;only word&quot;
</pre></div>

<p>then <tt>$array</tt> substitutes two words, &lsquo;<tt>first word</tt>&rsquo; and &lsquo;<tt>second
word</tt>&rsquo;, and <tt>$scalar</tt> substitutes a single word &lsquo;<tt>only word</tt>&rsquo;.  This
may be modified by explicit or implicit word-splitting, however.  The
full rules are complicated and are noted at the end.
</p>
<dl compact="compact">
<dt><tt>${</tt><var>name</var><tt>}</tt></dt>
<dd><p>The value, if any, of the parameter <var>name</var> is substituted.
The braces are required if the expansion is to be followed by
a letter, digit, or underscore that is not to be interpreted
as part of <var>name</var>.  In addition, more complicated forms of substitution
usually require the braces to be present; exceptions, which only apply if
the option <tt>KSH_ARRAYS</tt> is not set, are a single subscript or any colon
modifiers appearing after the name, or any of the characters &lsquo;<tt>^</tt>&rsquo;,
&lsquo;<tt>=</tt>&rsquo;, &lsquo;<tt>~</tt>&rsquo;, &lsquo;<tt>#</tt>&rsquo; or &lsquo;<tt>+</tt>&rsquo; appearing before the name, all of
which work with or without braces.
</p>
<p>If <var>name</var> is an array parameter, and the <tt>KSH_ARRAYS</tt> option is not
set, then the value of each
element of <var>name</var> is substituted, one element per word.  Otherwise, the
expansion results in one word only; with <tt>KSH_ARRAYS</tt>, this is the first
element of an array.  No field splitting is done on the result unless the
<tt>SH_WORD_SPLIT</tt> option is set.
See also the flags <tt>=</tt> and <tt>s:</tt><var>string</var><tt>:</tt>.
</p>
</dd>
<dt><tt>${+</tt><var>name</var><tt>}</tt></dt>
<dd><p>If <var>name</var> is the name of a set parameter &lsquo;<tt>1</tt>&rsquo; is substituted,
otherwise &lsquo;<tt>0</tt>&rsquo; is substituted.
</p>
</dd>
<dt><tt>${</tt><var>name</var><tt>-</tt><var>word</var><tt>}</tt></dt>
<dt><tt>${</tt><var>name</var><tt>:-</tt><var>word</var><tt>}</tt></dt>
<dd><p>If <var>name</var> is set, or in the second form is non-null, then substitute
its value; otherwise substitute <var>word</var>.  In the second form <var>name</var>
may be omitted, in which case <var>word</var> is always substituted.
</p>
</dd>
<dt><tt>${</tt><var>name</var><tt>+</tt><var>word</var><tt>}</tt></dt>
<dt><tt>${</tt><var>name</var><tt>:+</tt><var>word</var><tt>}</tt></dt>
<dd><p>If <var>name</var> is set, or in the second form is non-null, then substitute
<var>word</var>; otherwise substitute nothing.
</p>
</dd>
<dt><tt>${</tt><var>name</var><tt>=</tt><var>word</var><tt>}</tt></dt>
<dt><tt>${</tt><var>name</var><tt>:=</tt><var>word</var><tt>}</tt></dt>
<dt><tt>${</tt><var>name</var><tt>::=</tt><var>word</var><tt>}</tt></dt>
<dd><p>In the first form, if <var>name</var> is unset then set it to <var>word</var>; in the
second form, if <var>name</var> is unset or null then set it to <var>word</var>; and
in the third form, unconditionally set <var>name</var> to <var>word</var>.  In all
forms, the value of the parameter is then substituted.
</p>
</dd>
<dt><tt>${</tt><var>name</var><tt>?</tt><var>word</var><tt>}</tt></dt>
<dt><tt>${</tt><var>name</var><tt>:?</tt><var>word</var><tt>}</tt></dt>
<dd><p>In the first form, if <var>name</var> is set, or in the second form if <var>name</var>
is both set and non-null, then substitute its value; otherwise, print
<var>word</var> and exit from the shell.  Interactive shells instead return to
the prompt.  If <var>word</var> is omitted, then a standard message is printed.
</p>
</dd>
</dl>

<p>In any of the above expressions that test a variable and substitute an
alternate <var>word</var>, note that you can use standard shell quoting in the
<var>word</var> value to selectively override the splitting done by the
<tt>SH_WORD_SPLIT</tt> option and the <tt>=</tt> flag, but not splitting by the
<tt>s:</tt><var>string</var><tt>:</tt> flag.
</p>
<p>In the following expressions, when <var>name</var> is an array and
the substitution is not quoted, or if the &lsquo;<tt>(@)</tt>&rsquo; flag or the
<var>name</var><tt>[@]</tt> syntax is used, matching and replacement is
performed on each array element separately.
</p>
<dl compact="compact">
<dt><tt>${</tt><var>name</var><tt>#</tt><var>pattern</var><tt>}</tt></dt>
<dt><tt>${</tt><var>name</var><tt>##</tt><var>pattern</var><tt>}</tt></dt>
<dd><p>If the <var>pattern</var> matches the beginning of the value of
<var>name</var>, then substitute the value of <var>name</var> with
the matched portion deleted; otherwise, just
substitute the value of <var>name</var>.  In the first
form, the smallest matching pattern is preferred;
in the second form, the largest matching pattern is
preferred.
</p>
</dd>
<dt><tt>${</tt><var>name</var><tt>%</tt><var>pattern</var><tt>}</tt></dt>
<dt><tt>${</tt><var>name</var><tt>%%</tt><var>pattern</var><tt>}</tt></dt>
<dd><p>If the <var>pattern</var> matches the end of the value of
<var>name</var>, then substitute the value of <var>name</var> with
the matched portion deleted; otherwise, just
substitute the value of <var>name</var>.  In the first
form, the smallest matching pattern is preferred;
in the second form, the largest matching pattern is
preferred.
</p>
</dd>
<dt><tt>${</tt><var>name</var><tt>:#</tt><var>pattern</var><tt>}</tt></dt>
<dd><p>If the <var>pattern</var> matches the value of <var>name</var>, then substitute
the empty string; otherwise, just substitute the value of <var>name</var>.
If <var>name</var> is an array
the matching array elements are removed (use the &lsquo;<tt>(M)</tt>&rsquo; flag to
remove the non-matched elements).
</p>
</dd>
<dt><tt>${</tt><var>name</var><tt>:|</tt><var>arrayname</var><tt>}</tt></dt>
<dd><p>If <var>arrayname</var> is the name (N.B., not contents) of an array
variable, then any elements contained in <var>arrayname</var> are removed
from the substitution of <var>name</var>.  If the substitution is scalar,
either because <var>name</var> is a scalar variable or the expression is
quoted, the elements of <var>arrayname</var> are instead tested against the
entire expression.
</p>
</dd>
<dt><tt>${</tt><var>name</var><tt>:*</tt><var>arrayname</var><tt>}</tt></dt>
<dd><p>Similar to the preceding substitution, but in the opposite sense,
so that entries present in both the original substitution and as
elements of <var>arrayname</var> are retained and others removed.
</p>
</dd>
<dt><tt>${</tt><var>name</var><tt>:^</tt><var>arrayname</var><tt>}</tt></dt>
<dt><tt>${</tt><var>name</var><tt>:^^</tt><var>arrayname</var><tt>}</tt></dt>
<dd><p>Zips two arrays, such that the output array is twice as long as the
shortest (longest for &lsquo;<tt>:^^</tt>&rsquo;) of <tt>name</tt> and <tt>arrayname</tt>, with
the elements alternatingly being picked from them. For &lsquo;<tt>:^</tt>&rsquo;, if one
of the input arrays is longer, the output will stop when the end of the
shorter array is reached.  Thus,
</p>
<div class="example">
<pre class="example">a=(1 2 3 4); b=(a b); print ${a:^b}
</pre></div>

<p>will output &lsquo;<tt>1 a 2 b</tt>&rsquo;.  For &lsquo;<tt>:^^</tt>&rsquo;, then the input is repeated
until all of the longer array has been used up and the above will output
&lsquo;<tt>1 a 2 b 3 a 4 b</tt>&rsquo;.
</p>
<p>Either or both inputs may be a scalar, they will be treated as an array
of length 1 with the scalar as the only element. If either array is empty,
the other array is output with no extra elements inserted.
</p>
<p>Currently the following code will output &lsquo;<tt>a b</tt>&rsquo; and &lsquo;<tt>1</tt>&rsquo; as two separate
elements, which can be unexpected. The second print provides a workaround which
should continue to work if this is changed.
</p>
<div class="example">
<pre class="example">a=(a b); b=(1 2); print -l &quot;${a:^b}&quot;; print -l &quot;${${a:^b}}&quot;
</pre></div>

</dd>
<dt><tt>${</tt><var>name</var><tt>:</tt><var>offset</var><tt>}</tt></dt>
<dt><tt>${</tt><var>name</var><tt>:</tt><var>offset</var><tt>:</tt><var>length</var><tt>}</tt></dt>
<dd><p>This syntax gives effects similar to parameter subscripting
in the form <tt>$</tt><var>name</var><tt>[</tt><var>start</var><tt>,</tt><var>end</var><tt>]</tt>, but is
compatible with other shells; note that both <var>offset</var> and <var>length</var>
are interpreted differently from the components of a subscript.
</p>
<p>If <var>offset</var> is non-negative, then if the variable <var>name</var> is a
scalar substitute the contents starting <var>offset</var> characters from the
first character of the string, and if <var>name</var> is an array substitute
elements starting <var>offset</var> elements from the first element.  If
<var>length</var> is given, substitute that many characters or elements,
otherwise the entire rest of the scalar or array.
</p>
<p>A positive <var>offset</var> is always treated as the offset of a character or
element in <var>name</var> from the first character or element of the array
(this is different from native zsh subscript notation).  Hence 0
refers to the first character or element regardless of the setting of
the option <tt>KSH_ARRAYS</tt>.
</p>
<p>A negative offset counts backwards from the end of the scalar or array,
so that -1 corresponds to the last character or element, and so on.
</p>
<p>When positive, <var>length</var> counts from the <var>offset</var> position
toward the end of the scalar or array.  When negative, <var>length</var>
counts back from the end.  If this results in a position smaller
than <var>offset</var>, a diagnostic is printed and nothing is substituted.
</p>
<p>The option <tt>MULTIBYTE</tt> is obeyed, i.e. the offset and length
count multibyte characters where appropriate.
</p>
<p><var>offset</var> and <var>length</var> undergo the same set of shell substitutions
as for scalar assignment; in addition, they are then subject to arithmetic
evaluation.  Hence, for example
</p>
<div class="example">
<pre class="example">print ${foo:3}
print ${foo: 1 + 2}
print ${foo:$(( 1 + 2))}
print ${foo:$(echo 1 + 2)}
</pre></div>

<p>all have the same effect, extracting the string starting at the fourth
character of <tt>$foo</tt> if the substitution would otherwise return a scalar,
or the array starting at the fourth element if <tt>$foo</tt> would return an
array.  Note that with the option <tt>KSH_ARRAYS</tt> <tt>$foo</tt> always returns
a scalar (regardless of the use of the offset syntax) and a form
such as <tt>${foo[*]:3}</tt> is required to extract elements of an array named
<tt>foo</tt>.
</p>
<p>If <var>offset</var> is negative, the <tt>-</tt> may not appear immediately
after the <tt>:</tt> as this indicates the
<tt>${</tt><var>name</var><tt>:-</tt><var>word</var><tt>}</tt> form of substitution.  Instead, a space
may be inserted before the <tt>-</tt>.  Furthermore, neither <var>offset</var> nor
<var>length</var> may begin with an alphabetic character or <tt>&amp;</tt> as these are
used to indicate history-style modifiers.  To substitute a value from a
variable, the recommended approach is to precede it with a <tt>$</tt> as this
signifies the intention (parameter substitution can easily be rendered
unreadable); however, as arithmetic substitution is performed, the
expression <tt>${var: offs}</tt> does work, retrieving the offset from
<tt>$offs</tt>.
</p>
<p>For further compatibility with other shells there is a special case
for array offset 0.  This usually accesses the
first element of the array.  However, if the substitution refers to the
positional parameter array, e.g. <tt>$@</tt> or <tt>$*</tt>, then offset 0
instead refers to <tt>$0</tt>, offset 1 refers to <tt>$1</tt>, and so on.  In
other words, the positional parameter array is effectively extended by
prepending <tt>$0</tt>.  Hence <tt>${*:0:1}</tt> substitutes <tt>$0</tt> and
<tt>${*:1:1}</tt> substitutes <tt>$1</tt>.
</p>
</dd>
<dt><tt>${</tt><var>name</var><tt>/</tt><var>pattern</var><tt>/</tt><var>repl</var><tt>}</tt></dt>
<dt><tt>${</tt><var>name</var><tt>//</tt><var>pattern</var><tt>/</tt><var>repl</var><tt>}</tt></dt>
<dt><tt>${</tt><var>name</var><tt>:/</tt><var>pattern</var><tt>/</tt><var>repl</var><tt>}</tt></dt>
<dd><p>Replace the longest possible match of <var>pattern</var> in the expansion of
parameter <var>name</var> by string <var>repl</var>.  The first form
replaces just the first occurrence, the second form all occurrences,
and the third form replaces only if <var>pattern</var> matches the entire string.
Both <var>pattern</var> and <var>repl</var> are subject to double-quoted substitution,
so that expressions like <tt>${name/$opat/$npat}</tt> will work, but obey the
usual rule that pattern characters in <tt>$opat</tt> are not treated specially
unless either the option <tt>GLOB_SUBST</tt> is set, or <tt>$opat</tt> is instead
substituted as <tt>${~opat}</tt>.
</p>
<p>The <var>pattern</var> may begin with a &lsquo;<tt>#</tt>&rsquo;, in which case the
<var>pattern</var> must match at the start of the string, or &lsquo;<tt>%</tt>&rsquo;, in
which case it must match at the end of the string, or &lsquo;<tt>#%</tt>&rsquo; in which
case the <var>pattern</var> must match the entire string.  The <var>repl</var> may
be an empty string, in which case the final &lsquo;<tt>/</tt>&rsquo; may also be omitted.
To quote the final &lsquo;<tt>/</tt>&rsquo; in other cases it should be preceded by a
single backslash; this is not necessary if the
&lsquo;<tt>/</tt>&rsquo; occurs inside a substituted parameter.  Note also that the &lsquo;<tt>#</tt>&rsquo;,
&lsquo;<tt>%</tt>&rsquo; and &lsquo;<tt>#%</tt> are not active if they occur inside a substituted
parameter, even at the start.
</p>
<p>If, after quoting rules apply, <tt>${</tt><var>name</var><tt>}</tt> expands to an array,
the replacements act on each element individually.  Note also the
effect of the <tt>I</tt> and <tt>S</tt> parameter expansion flags below; however,
the flags <tt>M</tt>, <tt>R</tt>, <tt>B</tt>, <tt>E</tt> and <tt>N</tt> are not useful.
</p>
<p>For example,
</p>
<div class="example">
<pre class="example">foo=&quot;twinkle twinkle little star&quot; sub=&quot;t*e&quot; rep=&quot;spy&quot;
print ${foo//${~sub}/$rep}
print ${(S)foo//${~sub}/$rep}
</pre></div>

<p>Here, the &lsquo;<tt>~</tt>&rsquo; ensures that the text of <tt>$sub</tt> is treated as a
pattern rather than a plain string.  In the first case, the longest
match for <tt>t*e</tt> is substituted and the result is &lsquo;<tt>spy star</tt>&rsquo;,
while in the second case, the shortest matches are taken and the
result is &lsquo;<tt>spy spy lispy star</tt>&rsquo;.
</p>
</dd>
<dt><tt>${#</tt><var>spec</var><tt>}</tt></dt>
<dd><p>If <var>spec</var> is one of the above substitutions, substitute
the length in characters of the result instead of
the result itself.  If <var>spec</var> is an array expression,
substitute the number of elements of the result.
This has the side-effect that joining is skipped even in quoted
forms, which may affect other sub-expressions in <var>spec</var>.
Note that &lsquo;<tt>^</tt>&rsquo;, &lsquo;<tt>=</tt>&rsquo;, and &lsquo;<tt>~</tt>&rsquo;, below, must appear
to the left of &lsquo;<tt>#</tt>&rsquo; when these forms are combined.
</p>
<p>If the option <tt>POSIX_IDENTIFIERS</tt> is not set, and <var>spec</var> is a
simple name, then the braces are optional; this is true even
for special parameters so e.g. <tt>$#-</tt> and <tt>$#*</tt> take the length
of the string <tt>$-</tt> and the array <tt>$*</tt> respectively.  If
<tt>POSIX_IDENTIFIERS</tt> is set, then braces are required for
the <tt>#</tt> to be treated in this fashion.
</p>
</dd>
<dt><tt>${^</tt><var>spec</var><tt>}</tt></dt>
<dd><a name="index-RC_005fEXPAND_005fPARAM_002c-toggle"></a>
<a name="index-array-expansion-style_002c-rc"></a>
<a name="index-rc_002c-array-expansion-style"></a>
<p>Turn on the <tt>RC_EXPAND_PARAM</tt> option for the
evaluation of <var>spec</var>; if the &lsquo;<tt>^</tt>&rsquo; is doubled, turn it off.
When this option is set, array expansions of the form
<var>foo</var><tt>${</tt><var>xx</var><tt>}</tt><var>bar</var>,
where the parameter <var>xx</var>
is set to <tt>(</tt><var>a b c</var><tt>)</tt>, are substituted with
&lsquo;<var>fooabar foobbar foocbar</var>&rsquo; instead of the default
&lsquo;<var>fooa b cbar</var>&rsquo;.  Note that an empty array will therefore cause
all arguments to be removed.
</p>
<p>Internally, each such expansion is converted into the
equivalent list for brace expansion.  E.g., <tt>${^var}</tt> becomes
<tt>{$var[1],$var[2],</tt>...<tt>}</tt>, and is processed as described in
<a href="#Brace-Expansion">Brace Expansion</a> below: note, however, the expansion
happens immediately, with any explicit brace expansion
happening later.  If word splitting is also in effect the
<tt>$var[</tt><var>N</var><tt>]</tt> may themselves be split into different list
elements.
</p>
</dd>
<dt><tt>${=</tt><var>spec</var><tt>}</tt></dt>
<dd><a name="index-SH_005fWORD_005fSPLIT_002c-toggle"></a>
<a name="index-field-splitting_002c-sh-style_002c-parameter"></a>
<a name="index-sh_002c-field-splitting-style_002c-parameter"></a>
<p>Perform word splitting using the rules for <tt>SH_WORD_SPLIT</tt> during the
evaluation of <var>spec</var>, but regardless of whether the parameter appears in
double quotes; if the &lsquo;<tt>=</tt>&rsquo; is doubled, turn it off.
<a name="index-IFS_002c-use-of"></a>
This forces parameter expansions to be split into
separate words before substitution, using <tt>IFS</tt> as a delimiter.
This is done by default in most other shells.
</p>
<p>Note that splitting is applied to <var>word</var> in the assignment forms
of <var>spec</var> <em>before</em> the assignment to <var>name</var> is performed.
This affects the result of array assignments with the <tt>A</tt> flag.
</p>
</dd>
<dt><tt>${~</tt><var>spec</var><tt>}</tt></dt>
<dd><a name="index-GLOB_005fSUBST_002c-toggle"></a>
<p>Turn on the <tt>GLOB_SUBST</tt> option for the evaluation of
<var>spec</var>; if the &lsquo;<tt>~</tt>&rsquo; is doubled, turn it off.  When this option is
set, the string resulting from the expansion will be interpreted as a
pattern anywhere that is possible, such as in filename expansion and
filename generation and pattern-matching contexts like the right
hand side of the &lsquo;<tt>=</tt>&rsquo; and &lsquo;<tt>!=</tt>&rsquo; operators in conditions.
</p>
<p>In nested substitutions, note that the effect of the <tt>~</tt> applies to the
result of the current level of substitution.  A surrounding pattern
operation on the result may cancel it.  Hence, for example, if the
parameter <tt>foo</tt> is set to <tt>*</tt>, <tt>${~foo//\*/*.c}</tt> is substituted by
the pattern <tt>*.c</tt>, which may be expanded by filename generation, but
<tt>${${~foo}//\*/*.c}</tt> substitutes to the string <tt>*.c</tt>, which will not
be further expanded.
</p>
</dd>
</dl>

<p>If a <tt>${</tt>...<tt>}</tt> type parameter expression or a
<tt>$(</tt>...<tt>)</tt> type command substitution is used in place of
<var>name</var> above, it is expanded first and the result is used as if
it were the value of <var>name</var>.  Thus it is
possible to perform nested operations:  <tt>${${foo#head}%tail}</tt>
substitutes the value of <tt>$foo</tt> with both &lsquo;<tt>head</tt>&rsquo; and &lsquo;<tt>tail</tt>&rsquo;
deleted.  The form with <tt>$(</tt>...<tt>)</tt> is often useful in
combination with the flags described next; see the examples below.
Each <var>name</var> or nested <tt>${</tt>...<tt>}</tt> in a parameter expansion may
also be followed by a subscript expression as described in
<a href="Parameters.html#Array-Parameters">Array Parameters</a>.
</p>
<p>Note that double quotes may appear around nested expressions, in which
case only the part inside is treated as quoted; for example,
<tt>${(f)&quot;$(foo)&quot;}</tt> quotes the result of <tt>$(foo)</tt>, but the flag &lsquo;<tt>(f)</tt>&rsquo;
(see below) is applied using the rules for unquoted expansions.  Note
further that quotes are themselves nested in this context; for example, in
<tt>&quot;${(@f)&quot;$(foo)&quot;}&quot;</tt>, there are two sets of quotes, one surrounding the
whole expression, the other (redundant) surrounding the <tt>$(foo)</tt> as
before.
</p>

<hr>
<a name="Parameter-Expansion-Flags"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Parameter-Expansion" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Parameter-Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Rules" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.3.1 Parameter Expansion Flags</h3>
<a name="index-parameter-expansion-flags"></a>
<a name="index-flags_002c-parameter-expansion"></a>
<a name="index-substitution_002c-parameter_002c-flags"></a>
<p>If the opening brace is directly followed by an opening parenthesis,
the string up to the matching closing parenthesis will be taken as a
list of flags.  In cases where repeating a flag is meaningful, the
repetitions need not be consecutive; for example, &lsquo;(<tt>q%q%q</tt>)&rsquo;
means the same thing as the more readable &lsquo;(<tt>%%qqq</tt>)&rsquo;.  The
following flags are supported:
</p>
<dl compact="compact">
<dt><tt>#</tt></dt>
<dd><p>Evaluate the resulting words as numeric expressions and output the
characters corresponding to the resulting integer.  Note that this form is
entirely distinct from use of the <tt>#</tt> without parentheses.
</p>
<p>If the <tt>MULTIBYTE</tt> option is set and the number is greater than 127
(i.e. not an ASCII character) it is treated as a Unicode character.
</p>
</dd>
<dt><tt>%</tt></dt>
<dd><p>Expand all <tt>%</tt> escapes in the resulting words in the same way as in
prompts (see 
<a href="Prompt-Expansion.html#Prompt-Expansion">Prompt Expansion</a>). If this flag is given twice,
full prompt expansion is done on the resulting words, depending on the
setting of the <tt>PROMPT_PERCENT</tt>, <tt>PROMPT_SUBST</tt> and <tt>PROMPT_BANG</tt>
options.
</p>
</dd>
<dt><tt>@</tt></dt>
<dd><p>In double quotes, array elements are put into separate words.
E.g., &lsquo;<tt>&quot;${(@)foo}&quot;</tt>&rsquo; is equivalent to &lsquo;<tt>&quot;${foo[@]}&quot;</tt>&rsquo; and
&lsquo;<tt>&quot;${(@)foo[1,2]}&quot;</tt>&rsquo; is the same as &lsquo;<tt>&quot;$foo[1]&quot; &quot;$foo[2]&quot;</tt>&rsquo;.
This is distinct from <em>field splitting</em> by the <tt>f</tt>, <tt>s</tt>
or <tt>z</tt> flags, which still applies within each array element.
</p>
</dd>
<dt><tt>A</tt></dt>
<dd><p>Convert the substitution into an array expression, even if it otherwise
would be scalar.  This has lower precedence than subscripting, so one
level of nested expansion is required in order that subscripts apply
to array elements.  Thus <tt>${${(A</tt><tt>)</tt><var>name</var><tt>}[1]}</tt>
yields the full value of <var>name</var> when <var>name</var> is scalar.
</p>
<p>This assigns an array parameter with &lsquo;<tt>${</tt>...<tt>=</tt>...<tt>}</tt>&rsquo;,
&lsquo;<tt>${</tt>...<tt>:=</tt>...<tt>}</tt>&rsquo; or &lsquo;<tt>${</tt>...<tt>::=</tt>...<tt>}</tt>&rsquo;.
If this flag is repeated (as in &lsquo;<tt>AA</tt>&rsquo;), assigns an associative
array parameter.  Assignment is made before sorting or padding;
if field splitting is active, the <var>word</var> part is split before
assignment.  The <var>name</var> part may be a subscripted range for
ordinary arrays; when assigning an associative array, the <var>word</var>
part <em>must</em> be converted to an array, for example by using
&lsquo;<tt>${(AA)=</tt><var>name</var><tt>=</tt>...<tt>}</tt>&rsquo; to activate field splitting.
</p>
<p>Surrounding context such as additional nesting or use of the value
in a scalar assignment may cause the array to be joined back into
a single string again.
</p>
</dd>
<dt><tt>a</tt></dt>
<dd><p>Sort in array index order; when combined with &lsquo;<tt>O</tt>&rsquo; sort in reverse
array index order.  Note that &lsquo;<tt>a</tt>&rsquo; is therefore equivalent to the
default but &lsquo;<tt>Oa</tt>&rsquo; is useful for obtaining an array&rsquo;s elements in reverse
order.
</p>
</dd>
<dt><tt>b</tt></dt>
<dd><p>Quote with backslashes only characters that are special to pattern
matching. This is useful when the contents of the variable are to be
tested using <tt>GLOB_SUBST</tt>, including the <tt>${~</tt><var>...</var><tt>}</tt> switch.
</p>
<p>Quoting using one of the <tt>q</tt> family of flags does not work
for this purpose since quotes are not stripped from non-pattern
characters by <tt>GLOB_SUBST</tt>.  In other words,
</p>
<div class="example">
<pre class="example">pattern=${(q)str}
[[ $str = ${~pattern} ]]
</pre></div>

<p>works if <tt>$str</tt> is &lsquo;<tt>a*b</tt>&rsquo; but not if it is &lsquo;<tt>a b</tt>&rsquo;, whereas
</p>
<div class="example">
<pre class="example">pattern=${(b)str}
[[ $str = ${~pattern} ]]
</pre></div>

<p>is always true for any possible value of <tt>$str</tt>.
</p>
</dd>
<dt><tt>c</tt></dt>
<dd><p>With <tt>${#</tt><var>name</var><tt>}</tt>, count the total number of characters in an array,
as if the elements were concatenated with spaces between them.  This is not
a true join of the array, so other expressions used with this flag may have
an effect on the elements of the array before it is counted.
</p>
</dd>
<dt><tt>C</tt></dt>
<dd><p>Capitalize the resulting words.  &lsquo;Words&rsquo; in this case refers to sequences
of alphanumeric characters separated by non-alphanumerics, <em>not</em> to words
that result from field splitting.
</p>
</dd>
<dt><tt>D</tt></dt>
<dd><p>Assume the string or array elements contain directories and attempt
to substitute the leading part of these by names.  The remainder of
the path (the whole of it if the leading part was not substituted)
is then quoted so that the whole string can be used as a shell
argument.  This is the reverse of &lsquo;<tt>~</tt>&rsquo; substitution:  see
<a href="#Filename-Expansion">Filename Expansion</a>.
</p>
</dd>
<dt><tt>e</tt></dt>
<dd><p>Perform <em>parameter expansion</em>, <em>command substitution</em> and
<em>arithmetic expansion</em> on the result. Such expansions can be
nested but too deep recursion may have unpredictable effects.
</p>
</dd>
<dt><tt>f</tt></dt>
<dd><p>Split the result of the expansion at newlines. This is a shorthand
for &lsquo;<tt>ps:\n:</tt>&rsquo;.
</p>
</dd>
<dt><tt>F</tt></dt>
<dd><p>Join the words of arrays together using newline as a separator.
This is a shorthand for &lsquo;<tt>pj:\n:</tt>&rsquo;.
</p>
</dd>
<dt><tt>g:</tt><var>opts</var><tt>:</tt></dt>
<dd><p>Process escape sequences like the echo builtin when no options are given
(<tt>g::</tt>).  With the <tt>o</tt> option, octal escapes don&rsquo;t take a leading
zero.  With the <tt>c</tt> option, sequences like &lsquo;<tt>^X</tt>&rsquo; are also processed.
With the <tt>e</tt> option, processes &lsquo;<tt>\M-t</tt>&rsquo; and similar sequences like the
print builtin.  With both of the <tt>o</tt> and <tt>e</tt> options, behaves like the
print builtin except that in none of these modes is &lsquo;<tt>\c</tt>&rsquo; interpreted.
</p>
</dd>
<dt><tt>i</tt></dt>
<dd><p>Sort case-insensitively.  May be combined with &lsquo;<tt>n</tt>&rsquo; or &lsquo;<tt>O</tt>&rsquo;.
</p>
</dd>
<dt><tt>k</tt></dt>
<dd><p>If <var>name</var> refers to an associative array, substitute the <em>keys</em>
(element names) rather than the values of the elements.  Used with
subscripts (including ordinary arrays), force indices or keys to be
substituted even if the subscript form refers to values.  However,
this flag may not be combined with subscript ranges.  With the
<tt>KSH_ARRAYS</tt> option a subscript &lsquo;<tt>[*]</tt>&rsquo; or &lsquo;<tt>[@]</tt>&rsquo; is needed
to operate on the whole array, as usual.
</p>
</dd>
<dt><tt>L</tt></dt>
<dd><p>Convert all letters in the result to lower case.
</p>
</dd>
<dt><tt>n</tt></dt>
<dd><p>Sort decimal integers numerically; if the first differing
characters of two test strings are not digits, sorting
is lexical.   Integers with more initial zeroes
are sorted before those with fewer or none.  Hence the array &lsquo;<tt>foo1 foo02
foo2 foo3 foo20 foo23</tt>&rsquo; is sorted into the order shown.
May be combined with &lsquo;<tt>i</tt>&rsquo; or &lsquo;<tt>O</tt>&rsquo;.
</p>
</dd>
<dt><tt>o</tt></dt>
<dd><p>Sort the resulting words in ascending order; if this appears on its
own the sorting is lexical and case-sensitive (unless the locale
renders it case-insensitive).  Sorting in ascending order is the
default for other forms of sorting, so this is ignored if combined
with &lsquo;<tt>a</tt>&rsquo;, &lsquo;<tt>i</tt>&rsquo; or &lsquo;<tt>n</tt>&rsquo;.
</p>
</dd>
<dt><tt>O</tt></dt>
<dd><p>Sort the resulting words in descending order; &lsquo;<tt>O</tt>&rsquo; without &lsquo;<tt>a</tt>&rsquo;,
&lsquo;<tt>i</tt>&rsquo; or &lsquo;<tt>n</tt>&rsquo; sorts in reverse lexical order.  May be combined
with &lsquo;<tt>a</tt>&rsquo;, &lsquo;<tt>i</tt>&rsquo; or &lsquo;<tt>n</tt>&rsquo; to reverse the order of sorting.
</p>
</dd>
<dt><tt>P</tt></dt>
<dd><p>This forces the value of the parameter <var>name</var> to be interpreted as a
further parameter name, whose value will be used where appropriate.
Note that flags set with one of the <tt>typeset</tt> family of commands
(in particular case transformations) are not applied to the value of
<var>name</var> used in this fashion.
</p>
<p>If used with a nested parameter or command substitution, the result of that
will be taken as a parameter name in the same way.  For example, if you
have &lsquo;<tt>foo=bar</tt>&rsquo; and &lsquo;<tt>bar=baz</tt>&rsquo;, the strings <tt>${(P)foo}</tt>,
<tt>${(P)${foo}}</tt>, and <tt>${(P)$(echo bar)}</tt> will be expanded to
&lsquo;<tt>baz</tt>&rsquo;.
</p>
<p>Likewise, if the reference is itself nested, the expression with the
flag is treated as if it were directly replaced by the parameter name.
It is an error if this nested substitution produces an array with more
than one word.  For example, if &lsquo;<tt>name=assoc</tt>&rsquo; where the parameter
<tt>assoc</tt> is an associative array, then
&lsquo;<tt>${${(P)name}[elt]}</tt>&rsquo; refers to the element of the associative
subscripted &lsquo;<tt>elt</tt>&rsquo;.
</p>
</dd>
<dt><tt>q</tt></dt>
<dd><p>Quote characters that are special to the shell in the resulting words with
backslashes; unprintable or invalid characters are quoted using the
<tt>$'\</tt><var>NNN</var><tt>'</tt> form, with separate quotes for each octet.
</p>
<p>If this flag is given twice, the resulting words are quoted in single
quotes and if it is given three times, the words are quoted in double
quotes; in these forms no special handling of unprintable or invalid
characters is attempted.  If the flag is given four times, the words are
quoted in single quotes preceded by a <tt>$</tt>.  Note that in all three of
these forms quoting is done unconditionally, even if this does not change
the way the resulting string would be interpreted by the shell.
</p>
<p>If a <tt>q-</tt> is given (only a single <tt>q</tt> may appear), a minimal
form of single quoting is used that only quotes the string if needed to
protect special characters.  Typically this form gives the most readable
output.
</p>
<p>If a <tt>q+</tt> is given, an extended form of minmal quoting is used that
causes unprintable characters to be rendered using <tt>$'</tt><var>...</var><tt>'</tt>.
This quoting is similar to that used by the output of values by the
<tt>typeset</tt> family of commands.
</p>
</dd>
<dt><tt>Q</tt></dt>
<dd><p>Remove one level of quotes from the resulting words.
</p>
</dd>
<dt><tt>t</tt></dt>
<dd><p>Use a string describing the type of the parameter where the value
of the parameter would usually appear. This string consists of keywords
separated by hyphens (&lsquo;<tt>-</tt>&rsquo;). The first keyword in the string describes
the main type, it can be one of &lsquo;<tt>scalar</tt>&rsquo;, &lsquo;<tt>array</tt>&rsquo;, &lsquo;<tt>integer</tt>&rsquo;,
&lsquo;<tt>float</tt>&rsquo; or &lsquo;<tt>association</tt>&rsquo;. The other keywords describe the type in
more detail:
</p>
<dl compact="compact">
<dt><tt>local</tt></dt>
<dd><p>for local parameters
</p>
</dd>
<dt><tt>left</tt></dt>
<dd><p>for left justified parameters
</p>
</dd>
<dt><tt>right_blanks</tt></dt>
<dd><p>for right justified parameters with leading blanks
</p>
</dd>
<dt><tt>right_zeros</tt></dt>
<dd><p>for right justified parameters with leading zeros
</p>
</dd>
<dt><tt>lower</tt></dt>
<dd><p>for parameters whose value is converted to all lower case when it is
expanded
</p>
</dd>
<dt><tt>upper</tt></dt>
<dd><p>for parameters whose value is converted to all upper case when it is
expanded
</p>
</dd>
<dt><tt>readonly</tt></dt>
<dd><p>for readonly parameters
</p>
</dd>
<dt><tt>tag</tt></dt>
<dd><p>for tagged parameters
</p>
</dd>
<dt><tt>export</tt></dt>
<dd><p>for exported parameters
</p>
</dd>
<dt><tt>unique</tt></dt>
<dd><p>for arrays which keep only the first occurrence of duplicated values
</p>
</dd>
<dt><tt>hide</tt></dt>
<dd><p>for parameters with the &lsquo;hide&rsquo; flag
</p>
</dd>
<dt><tt>hideval</tt></dt>
<dd><p>for parameters with the &lsquo;hideval&rsquo; flag
</p>
</dd>
<dt><tt>special</tt></dt>
<dd><p>for special parameters defined by the shell
</p>
</dd>
</dl>

</dd>
<dt><tt>u</tt></dt>
<dd><p>Expand only the first occurrence of each unique word.
</p>
</dd>
<dt><tt>U</tt></dt>
<dd><p>Convert all letters in the result to upper case.
</p>
</dd>
<dt><tt>v</tt></dt>
<dd><p>Used with <tt>k</tt>, substitute (as two consecutive words) both the key
and the value of each associative array element.  Used with subscripts,
force values to be substituted even if the subscript form refers to
indices or keys.
</p>
</dd>
<dt><tt>V</tt></dt>
<dd><p>Make any special characters in the resulting words visible.
</p>
</dd>
<dt><tt>w</tt></dt>
<dd><p>With <tt>${#</tt><var>name</var><tt>}</tt>, count words in arrays or strings; the <tt>s</tt>
flag may be used to set a word delimiter.
</p>
</dd>
<dt><tt>W</tt></dt>
<dd><p>Similar to <tt>w</tt> with the difference that empty words between
repeated delimiters are also counted.
</p>
</dd>
<dt><tt>X</tt></dt>
<dd><p>With this flag, parsing errors occurring with the <tt>Q</tt>, <tt>e</tt> and <tt>#</tt>
flags or the pattern matching forms such as
&lsquo;<tt>${</tt><var>name</var><tt>#</tt><var>pattern</var><tt>}</tt>&rsquo; are reported.  Without the flag,
errors are silently ignored.
</p>
</dd>
<dt><tt>z</tt></dt>
<dd><p>Split the result of the expansion into words using shell parsing to
find the words, i.e. taking into account any quoting in the value.
Comments are not treated specially but as ordinary strings, similar
to interactive shells with the <tt>INTERACTIVE_COMMENTS</tt> option unset
(however, see the <tt>Z</tt> flag below for related options)
</p>
<p>Note that this is done very late, even later than the &lsquo;<tt>(s)</tt>&rsquo; flag. So to
access single words in the result use nested expansions as
in &lsquo;<tt>${${(z)foo}[2]}</tt>&rsquo;. Likewise, to remove the quotes in the
resulting words use &lsquo;<tt>${(Q)${(z)foo}}</tt>&rsquo;.
</p>
</dd>
<dt><tt>0</tt></dt>
<dd><p>Split the result of the expansion on null bytes.  This is a shorthand
for &lsquo;<tt>ps:\0:</tt>&rsquo;.
</p>
</dd>
</dl>

<p>The following flags (except <tt>p</tt>) are followed by one or more arguments
as shown.  Any character, or the matching pairs &lsquo;<tt>(</tt>...<tt>)</tt>&rsquo;,
&lsquo;<tt>{</tt>...<tt>}</tt>&rsquo;, &lsquo;<tt>[</tt>...<tt>]</tt>&rsquo;, or &lsquo;<tt>&lt;</tt>...<tt>&gt;</tt>&rsquo;, may be used in place
of a colon as delimiters, but note that when a flag takes more than one
argument, a matched pair of delimiters must surround each argument.
</p>
<dl compact="compact">
<dt><tt>p</tt></dt>
<dd><p>Recognize the same escape sequences as the <tt>print</tt> builtin
in string arguments to any of the flags described below that
follow this argument.
</p>
<p>Alternatively, with this option string arguments may be in the form
<tt>$</tt><var>var</var> in which case the value of the variable is substituted.
Note this form is strict; the string argument does not undergo general
parameter expansion.
</p>
<p>For example,
</p>
<div class="example">
<pre class="example">sep=:
val=a:b:c
print ${(ps.$sep.)val}
</pre></div>

<p>splits the variable on a <tt>:</tt>.
</p>
</dd>
<dt><tt>~</tt></dt>
<dd><p>Strings inserted into the expansion by any of the flags below are to
be treated as patterns.  This applies to the string arguments of flags
that follow <tt>~</tt> within the same set of parentheses.  Compare with <tt>~</tt>
outside parentheses, which forces the entire substituted string to
be treated as a pattern.  Hence, for example,
</p>
<div class="example">
<pre class="example">[[ &quot;?&quot; = ${(~j.|.)array} ]]
</pre></div>

<p>treats &lsquo;<tt>|</tt>&rsquo; as a pattern and succeeds if and only if <tt>$array</tt>
contains the string &lsquo;<tt>?</tt>&rsquo; as an element.  The <tt>~</tt> may be
repeated to toggle the behaviour; its effect only lasts to the
end of the parenthesised group.
</p>
</dd>
<dt><tt>j:</tt><var>string</var><tt>:</tt></dt>
<dd><p>Join the words of arrays together using <var>string</var> as a separator.
<a name="index-SH_005fWORD_005fSPLIT_002c-use-of"></a>
Note that this occurs before field splitting by the <tt>s:</tt><var>string</var><tt>:</tt>
flag or the <tt>SH_WORD_SPLIT</tt> option.
</p>
</dd>
<dt><tt>l:</tt><var>expr</var><tt>::</tt><var>string1</var><tt>::</tt><var>string2</var><tt>:</tt></dt>
<dd><p>Pad the resulting words on the left.  Each word will be truncated if
required and placed in a field <var>expr</var> characters wide.
</p>
<p>The arguments <tt>:</tt><var>string1</var><tt>:</tt> and <tt>:</tt><var>string2</var><tt>:</tt> are
optional; neither, the first, or both may be given.  Note that the same
pairs of delimiters must be used for each of the three arguments.  The
space to the left will be filled with <var>string1</var> (concatenated as
often as needed) or spaces if <var>string1</var> is not given.  If both
<var>string1</var> and <var>string2</var> are given, <var>string2</var> is inserted once
directly to the left of each word, truncated if necessary, before
<var>string1</var> is used to produce any remaining padding.
</p>
<p>If either of <var>string1</var> or <var>string2</var> is present but empty,
i.e. there are two delimiters together at that point, the first
character of <tt>$IFS</tt> is used instead.
</p>
<p>If the <tt>MULTIBYTE</tt> option is in effect, the flag <tt>m</tt> may also
be given, in which case widths will be used for the calculation of
padding; otherwise individual multibyte characters are treated as occupying
one unit of width.
</p>
<p>If the <tt>MULTIBYTE</tt> option is not in effect, each byte in the string is
treated as occupying one unit of width.
</p>
<p>Control characters are always assumed to be one unit wide; this allows the
mechanism to be used for generating repetitions of control characters.
</p>
</dd>
<dt><tt>m</tt></dt>
<dd><p>Only useful together with one of the flags <tt>l</tt> or <tt>r</tt> or with the
<tt>#</tt> length operator when the <tt>MULTIBYTE</tt> option
is in effect.  Use the character width reported by the system in
calculating how much of the string it occupies or the overall
length of the string.  Most printable characters have a width of one
unit, however certain Asian character sets and certain special effects
use wider characters; combining characters have zero width.
Non-printable characters are arbitrarily counted as zero width; how they
would actually be displayed will vary.
</p>
<p>If the <tt>m</tt> is repeated, the character either counts zero (if it has
zero width), else one.  For printable character strings this has the
effect of counting the number of glyphs (visibly separate characters),
except for the case where combining characters themselves have non-zero
width (true in certain alphabets).
</p>
</dd>
<dt><tt>r:</tt><var>expr</var><tt>::</tt><var>string1</var><tt>::</tt><var>string2</var><tt>:</tt></dt>
<dd><p>As <tt>l</tt>, but pad the words on the right and insert <var>string2</var>
immediately to the right of the string to be padded.
</p>
<p>Left and right padding may be used together.  In this case the strategy
is to apply left padding to the first half width of each of the resulting
words, and right padding to the second half.  If the string to be
padded has odd width the extra padding is applied on the left.
</p>
</dd>
<dt><tt>s:</tt><var>string</var><tt>:</tt></dt>
<dd><p>Force field splitting at the
separator <var>string</var>.  Note that a <var>string</var> of two or more
characters means that all of them must match in sequence; this differs from
the treatment of two or more characters in the <tt>IFS</tt> parameter.
See also the <tt>=</tt> flag and the <tt>SH_WORD_SPLIT</tt> option.  An empty
string may also be given in which case every character will be a separate
element.
</p>
<p>For historical reasons, the usual behaviour that empty array elements
are retained inside double quotes is disabled for arrays generated
by splitting; hence the following:
</p>
<div class="example">
<pre class="example">line=&quot;one::three&quot;
print -l &quot;${(s.:.)line}&quot;
</pre></div>

<p>produces two lines of output for <tt>one</tt> and <tt>three</tt> and elides the
empty field.  To override this behaviour, supply the &lsquo;<tt>(@)</tt>&rsquo; flag as well,
i.e.  <tt>&quot;${(@s.:.)line}&quot;</tt>.
</p>
</dd>
<dt><tt>Z:</tt><var>opts</var><tt>:</tt></dt>
<dd><p>As <tt>z</tt> but takes a combination of option letters between a following
pair of delimiter characters.  With no options the effect is identical
to <tt>z</tt>.  <tt>(Z+c+)</tt>
causes comments to be parsed as a string and retained; any field in the
resulting array beginning with an unquoted comment character is a
comment.  <tt>(Z+C+)</tt> causes comments to be parsed
and removed.  The rule for comments is standard: anything between a word
starting with the third character of <tt>$HISTCHARS</tt>, default <tt>#</tt>, up to
the next newline is a comment.  <tt>(Z+n+)</tt> causes
unquoted newlines to be treated as ordinary whitespace, else they are
treated as if they are shell code delimiters and converted to
semicolons.  Options are combined within the same set of delimiters,
e.g. <tt>(Z+Cn+)</tt>.
</p>
</dd>
<dt><tt>_:</tt><var>flags</var><tt>:</tt></dt>
<dd><p>The underscore (<tt>_</tt>) flag is reserved for future use.  As of this
revision of zsh, there are no valid <var>flags</var>; anything following an
underscore, other than an empty pair of delimiters, is treated as an
error, and the flag itself has no effect.
</p>
</dd>
</dl>

<p>The following flags are meaningful with the <tt>${</tt>...<tt>#</tt>...<tt>}</tt> or
<tt>${</tt>...<tt>%</tt>...<tt>}</tt> forms.  The <tt>S</tt> and <tt>I</tt> flags may also be
used with the <tt>${</tt>...<tt>/</tt>...<tt>}</tt> forms.
</p>
<dl compact="compact">
<dt><tt>S</tt></dt>
<dd><p>Search substrings as well as beginnings or ends; with <tt>#</tt> start
from the beginning and with <tt>%</tt> start from the end of the string.
With substitution via <tt>${</tt>...<tt>/</tt>...<tt>}</tt> or
<tt>${</tt>...<tt>//</tt>...<tt>}</tt>, specifies non-greedy matching, i.e. that the
shortest instead of the longest match should be replaced.
</p>
</dd>
<dt><tt>I:</tt><var>expr</var><tt>:</tt></dt>
<dd><p>Search the <var>expr</var>th match (where <var>expr</var> evaluates to a number).
This only applies when searching for substrings, either with the <tt>S</tt>
flag, or with <tt>${</tt>...<tt>/</tt>...<tt>}</tt> (only the <var>expr</var>th match is
substituted) or <tt>${</tt>...<tt>//</tt>...<tt>}</tt> (all matches from the
<var>expr</var>th on are substituted).  The default is to take the first match.
</p>
<p>The <var>expr</var>th match is counted such that there is either one or zero
matches from each starting position in the string, although for global
substitution matches overlapping previous replacements are ignored.  With
the <tt>${</tt>...<tt>%</tt>...<tt>}</tt> and <tt>${</tt>...<tt>%%</tt>...<tt>}</tt> forms, the starting
position for the match moves backwards from the end as the index increases,
while with the other forms it moves forward from the start.
</p>
<p>Hence with the string
</p><div class="example">
<pre class="example">which switch is the right switch for Ipswich?
</pre></div>
<p>substitutions of the form
<tt>${</tt>(<tt>SI:</tt><var>N</var><tt>:</tt>)<tt>string#w*ch}</tt> as <var>N</var> increases
from 1 will match and remove &lsquo;<tt>which</tt>&rsquo;, &lsquo;<tt>witch</tt>&rsquo;, &lsquo;<tt>witch</tt>&rsquo; and
&lsquo;<tt>wich</tt>&rsquo;; the form using &lsquo;<tt>##</tt>&rsquo; will match and remove &lsquo;<tt>which switch
is the right switch for Ipswich</tt>&rsquo;, &lsquo;<tt>witch is the right switch for
Ipswich</tt>&rsquo;, &lsquo;<tt>witch for Ipswich</tt>&rsquo; and &lsquo;<tt>wich</tt>&rsquo;. The form using &lsquo;<tt>%</tt>&rsquo;
will remove the same matches as for &lsquo;<tt>#</tt>&rsquo;, but in reverse order, and the
form using &lsquo;<tt>%%</tt>&rsquo; will remove the same matches as for &lsquo;<tt>##</tt>&rsquo; in reverse
order.
</p>
</dd>
<dt><tt>B</tt></dt>
<dd><p>Include the index of the beginning of the match in the result.
</p>
</dd>
<dt><tt>E</tt></dt>
<dd><p>Include the index one character past the end of the match in the result
(note this is inconsistent with other uses of parameter index).
</p>
</dd>
<dt><tt>M</tt></dt>
<dd><p>Include the matched portion in the result.
</p>
</dd>
<dt><tt>N</tt></dt>
<dd><p>Include the length of the match in the result.
</p>
</dd>
<dt><tt>R</tt></dt>
<dd><p>Include the unmatched portion in the result (the <em>R</em>est).
</p>
</dd>
</dl>


<hr>
<a name="Rules"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Parameter-Expansion-Flags" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Parameter-Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Examples" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.3.2 Rules</h3>

<p>Here is a summary of the rules for substitution; this assumes that braces
are present around the substitution, i.e. <tt>${</tt><var>...</var><tt>}</tt>.  Some particular
examples are given below.  Note that the Zsh Development Group accepts
<em>no responsibility</em> for any brain damage which may occur during the
reading of the following rules.
</p>
<dl compact="compact">
<dt><tt>1.</tt> <em>Nested substitution</em></dt>
<dd><p>If multiple nested <tt>${</tt><var>...</var><tt>}</tt> forms are present, substitution is
performed from the inside outwards.  At each level, the substitution takes
account of whether the current value is a scalar or an array, whether the
whole substitution is in double quotes, and what flags are supplied to the
current level of substitution, just as if the nested substitution were the
outermost.  The flags are not propagated up to enclosing
substitutions; the nested substitution will return either a scalar or an
array as determined by the flags, possibly adjusted for quoting.  All the
following steps take place where applicable at all levels of substitution.
</p>
<p>Note that, unless the &lsquo;<tt>(P)</tt>&rsquo; flag is present, the flags and any
subscripts apply directly to the value of the nested substitution; for
example, the expansion <tt>${${foo}}</tt> behaves exactly the same as
<tt>${foo}</tt>.  When the &lsquo;<tt>(P)</tt>&rsquo; flag is present in a nested substitution,
the other substitution rules are applied to the value <em>before</em> it is
interpreted as a name, so <tt>${${(P)foo}}</tt> may differ from <tt>${(P)foo}</tt>.
</p>
<p>At each nested level of substitution, the substituted words undergo all
forms of single-word substitution (i.e. not filename generation), including
command substitution, arithmetic expansion and filename expansion
(i.e. leading <tt>~</tt> and <tt>=</tt>).  Thus, for example, <tt>${${:-=cat}:h}</tt>
expands to the directory where the <tt>cat</tt> program resides.  (Explanation:
the internal substitution has no parameter but a default value <tt>=cat</tt>,
which is expanded by filename expansion to a full path; the outer
substitution then applies the modifier <tt>:h</tt> and takes the directory part
of the path.)
</p>
</dd>
<dt><tt>2.</tt> <em>Internal parameter flags</em></dt>
<dd><p>Any parameter flags set by one of the <tt>typeset</tt> family of commands, in
particular the <tt>-L</tt>, <tt>-R</tt>, <tt>-Z</tt>, <tt>-u</tt> and <tt>-l</tt> options for
padding and capitalization, are applied directly to the parameter value.
Note these flags are options to the command, e.g. &lsquo;<tt>typeset -Z</tt>&rsquo;; they
are not the same as the flags used within parameter substitutions.
</p>
<p>At the outermost level of substitution, the &lsquo;<tt>(P)</tt>&rsquo; flag (rule <tt>4.</tt>)
ignores these transformations and uses the unmodified value of the
parameter as the name to be replaced.  This is usually the desired
behavior because padding may make the value syntactically illegal as a
parameter name, but if capitalization changes are desired, use the
<tt>${${(P)foo}}</tt> form (rule <tt>25.</tt>).
</p>
</dd>
<dt><tt>3.</tt> <em>Parameter subscripting</em></dt>
<dd><p>If the value is a raw parameter reference with a subscript, such as
<tt>${</tt><var>var</var><tt>[3]}</tt>, the effect of subscripting is applied directly to
the parameter.  Subscripts are evaluated left to right; subsequent
subscripts apply to the scalar or array value yielded by the previous
subscript.  Thus if <tt>var</tt> is an array, <tt>${var[1][2]}</tt> is the second
character of the first word, but <tt>${var[2,4][2]}</tt> is the entire third
word (the second word of the range of words two through four of the
original array).  Any number of subscripts may appear.  Flags such as
&lsquo;<tt>(k)</tt>&rsquo; and &lsquo;<tt>(v)</tt>&rsquo; which alter the result of subscripting are applied.
</p>
</dd>
<dt><tt>4.</tt> <em>Parameter name replacement</em></dt>
<dd><p>At the outermost level of nesting only, the &lsquo;<tt>(P)</tt>&rsquo; flag is applied.  This
treats the value so far as a parameter name (which may include a subscript
expression) and replaces that with the corresponding value.  This
replacement occurs later if the &lsquo;<tt>(P)</tt>&rsquo; flag appears in a nested
substitution.
</p>
<p>If the value so far names a parameter that has internal flags (rule <tt>2.</tt>),
those internal flags are applied to the new value after replacement.
</p>
</dd>
<dt><tt>5.</tt> <em>Double-quoted joining</em></dt>
<dd><p>If the value after this process is an array, and the substitution
appears in double quotes, and neither an &lsquo;<tt>(@)</tt>&rsquo; flag nor a &lsquo;<tt>#</tt>&rsquo;
length operator is present at the current level, then words of the
value are joined with the first character of the parameter <tt>$IFS</tt>,
by default a space, between each word (single word arrays are not
modified).  If the &lsquo;<tt>(j)</tt>&rsquo; flag is present, that is used for joining
instead of <tt>$IFS</tt>.
</p>
</dd>
<dt><tt>6.</tt> <em>Nested subscripting</em></dt>
<dd><p>Any remaining subscripts (i.e. of a nested substitution) are evaluated at
this point, based on whether the value is an array or a scalar.  As with
<tt>3.</tt>, multiple subscripts can appear.  Note that <tt>${foo[2,4][2]}</tt> is
thus equivalent to <tt>${${foo[2,4]}[2]}</tt> and also to
<tt>&quot;${${(@)foo[2,4]}[2]}&quot;</tt> (the nested substitution returns an array in
both cases), but not to <tt>&quot;${${foo[2,4]}[2]}&quot;</tt> (the nested substitution
returns a scalar because of the quotes).
</p>
</dd>
<dt><tt>7.</tt> <em>Modifiers</em></dt>
<dd><p>Any modifiers, as specified by a trailing &lsquo;<tt>#</tt>&rsquo;, &lsquo;<tt>%</tt>&rsquo;, &lsquo;<tt>/</tt>&rsquo;
(possibly doubled) or by a set of modifiers of the form &lsquo;<tt>:...</tt>&rsquo; (see
<a href="#Modifiers">Modifiers</a> in <a href="#History-Expansion">History Expansion</a>), are applied to the words
of the value at this level.
</p>
</dd>
<dt><tt>8.</tt> <em>Character evaluation</em></dt>
<dd><p>Any &lsquo;<tt>(#)</tt>&rsquo; flag is applied, evaluating the result so far numerically
as a character.
</p>
</dd>
<dt><tt>9.</tt> <em>Length</em></dt>
<dd><p>Any initial &lsquo;<tt>#</tt>&rsquo; modifier, i.e. in the form <tt>${#</tt><var>var</var><tt>}</tt>, is
used to evaluate the length of the expression so far.
</p>
</dd>
<dt><tt>10.</tt> <em>Forced joining</em></dt>
<dd><p>If the &lsquo;<tt>(j)</tt>&rsquo; flag is present, or no &lsquo;<tt>(j)</tt>&rsquo; flag is present but
the string is to be split as given by rule <tt>11.</tt>, and joining
did not take place at rule <tt>5.</tt>, any words in the value are joined
together using the given string or the first character of <tt>$IFS</tt> if none.
Note that the &lsquo;<tt>(F)</tt>&rsquo; flag implicitly supplies a string for joining in this
manner.
</p>
</dd>
<dt><tt>11.</tt> <em>Simple word splitting</em></dt>
<dd><p>If one of the &lsquo;<tt>(s)</tt>&rsquo; or &lsquo;<tt>(f)</tt>&rsquo; flags are present, or the &lsquo;<tt>=</tt>&rsquo;
specifier was present (e.g. <tt>${=</tt><var>var</var><tt>}</tt>), the word is split on
occurrences of the specified string, or (for <tt>=</tt> with neither of the two
flags present) any of the characters in <tt>$IFS</tt>.
</p>
<p>If no &lsquo;<tt>(s)</tt>&rsquo;, &lsquo;<tt>(f)</tt>&rsquo; or &lsquo;<tt>=</tt>&rsquo; was given, but the word is not
quoted and the option <tt>SH_WORD_SPLIT</tt> is set, the word is split on
occurrences of any of the characters in <tt>$IFS</tt>.  Note this step, too,
takes place at all levels of a nested substitution.
</p>
</dd>
<dt><tt>12.</tt> <em>Case modification</em></dt>
<dd><p>Any case modification from one of the flags &lsquo;<tt>(L)</tt>&rsquo;, &lsquo;<tt>(U)</tt>&rsquo; or &lsquo;<tt>(C)</tt>&rsquo;
is applied.
</p>
</dd>
<dt><tt>13.</tt> <em>Escape sequence replacement</em></dt>
<dd><p>First any replacements from the &lsquo;<tt>(g)</tt>&rsquo; flag are performed, then any
prompt-style formatting from the &lsquo;<tt>(%)</tt>&rsquo; family of flags is applied.
</p>
</dd>
<dt><tt>14.</tt> <em>Quote application</em></dt>
<dd><p>Any quoting or unquoting using &lsquo;<tt>(q)</tt>&rsquo; and &lsquo;<tt>(Q)</tt>&rsquo; and related flags
is applied.
</p>
</dd>
<dt><tt>15.</tt> <em>Directory naming</em></dt>
<dd><p>Any directory name substitution using &lsquo;<tt>(D)</tt>&rsquo; flag is applied.
</p>
</dd>
<dt><tt>16.</tt> <em>Visibility enhancement</em></dt>
<dd><p>Any modifications to make characters visible using the &lsquo;<tt>(V)</tt>&rsquo; flag
are applied.
</p>
</dd>
<dt><tt>17.</tt> <em>Lexical word splitting</em></dt>
<dd><p>If the &rsquo;<tt>(z)</tt>&rsquo; flag or one of the forms of the &rsquo;<tt>(Z)</tt>&rsquo; flag is
present, the word is split as if it were a shell command line, so that
quotation marks and other metacharacters are used to decide what
constitutes a word.  Note this form of splitting is entirely distinct
from that described by rule <tt>11.</tt>: it does not use <tt>$IFS</tt>, and
does not cause forced joining.
</p>
</dd>
<dt><tt>18.</tt> <em>Uniqueness</em></dt>
<dd><p>If the result is an array and the &lsquo;<tt>(u)</tt>&rsquo; flag was present, duplicate
elements are removed from the array.
</p>
</dd>
<dt><tt>19.</tt> <em>Ordering</em></dt>
<dd><p>If the result is still an array and one of the &lsquo;<tt>(o)</tt>&rsquo; or &lsquo;<tt>(O)</tt>&rsquo; flags
was present, the array is reordered.
</p>
</dd>
<dt><tt>20.</tt> <tt>RC_EXPAND_PARAM</tt></dt>
<dd><p>At this point the decision is made whether any resulting array elements
are to be combined element by element with surrounding text, as given
by either the <tt>RC_EXPAND_PARAM</tt> option or the &lsquo;<tt>^</tt>&rsquo; flag.
</p>
</dd>
<dt><tt>21.</tt> <em>Re-evaluation</em></dt>
<dd><p>Any &lsquo;<tt>(e)</tt>&rsquo; flag is applied to the value, forcing it to be re-examined
for new parameter substitutions, but also for command and arithmetic
substitutions.
</p>
</dd>
<dt><tt>22.</tt> <em>Padding</em></dt>
<dd><p>Any padding of the value by the &lsquo;<tt>(l.</tt><var>fill</var><tt>.)</tt>&rsquo; or
&lsquo;<tt>(r.</tt><var>fill</var><tt>.)</tt>&rsquo; flags is applied.
</p>
</dd>
<dt><tt>23.</tt> <em>Semantic joining</em></dt>
<dd><p>In contexts where expansion semantics requires a single word to
result, all words are rejoined with the first character of <tt>IFS</tt>
between.  So in &lsquo;<tt>${(P</tt><tt>)${(f</tt><tt>)lines}}</tt>&rsquo;
the value of <tt>${lines}</tt> is split at newlines, but then must be
joined again before the &lsquo;<tt>(P)</tt>&rsquo; flag can be applied.
</p>
<p>If a single word is not required, this rule is skipped.
</p>
</dd>
<dt><tt>24.</tt> <em>Empty argument removal</em></dt>
<dd><p>If the substitution does not appear in double quotes, any resulting
zero-length argument, whether from a scalar or an element of an array,
is elided from the list of arguments inserted into the command line.
</p>
<p>Strictly speaking, the removal happens later as the same happens with
other forms of substitution; the point to note here is simply that
it occurs after any of the above parameter operations.
</p>
</dd>
<dt><tt>25.</tt> <em>Nested parameter name replacement</em></dt>
<dd><p>If the &lsquo;<tt>(P)</tt>&rsquo; flag is present and rule <tt>4.</tt> has not applied, the
value so far is treated as a parameter name (which may include a subscript
expression) and replaced with the corresponding value, with internal flags
(rule <tt>2.</tt>) applied to the new value.
</p>
</dd>
</dl>


<hr>
<a name="Examples"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Rules" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Parameter-Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Command-Substitution" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.3.3 Examples</h3>
<p>The flag <tt>f</tt> is useful to split a double-quoted substitution line by
line.  For example, <tt>${(f)&quot;$(&lt;</tt><var>file</var><tt>)&quot;}</tt>
substitutes the contents of <var>file</var> divided so that each line is
an element of the resulting array.  Compare this with the effect of
<tt>$</tt><tt>(&lt;</tt><var>file</var><tt>)</tt> alone, which divides the file
up by words, or the same inside double quotes, which makes the entire
content of the file a single string.
</p>
<p>The following illustrates the rules for nested parameter expansions.
Suppose that <tt>$foo</tt> contains the array <tt>(bar baz</tt><tt>)</tt>:
</p>
<dl compact="compact">
<dt><tt>&quot;${(@)${foo}[1]}&quot;</tt></dt>
<dd><p>This produces the result <tt>b</tt>.  First, the inner substitution
<tt>&quot;${foo}&quot;</tt>, which has no array (<tt>@</tt>) flag, produces a single word
result <tt>&quot;bar baz&quot;</tt>.  The outer substitution <tt>&quot;${(@)...[1]}&quot;</tt> detects
that this is a scalar, so that (despite the &lsquo;<tt>(@)</tt>&rsquo; flag) the subscript
picks the first character. 
</p>
</dd>
<dt><tt>&quot;${${(@)foo}[1]}&quot;</tt></dt>
<dd><p>This produces the result &lsquo;<tt>bar</tt>&rsquo;.  In this case, the inner substitution
<tt>&quot;${(@)foo}&quot;</tt> produces the array &lsquo;<tt>(bar baz</tt><tt>)</tt>&rsquo;.  The outer
substitution <tt>&quot;${...[1]}&quot;</tt> detects that this is an array and picks the
first word.  This is similar to the simple case <tt>&quot;${foo[1]}&quot;</tt>.
</p>
</dd>
</dl>

<p>As an example of the rules for word splitting and joining, suppose <tt>$foo</tt>
contains the array &lsquo;<tt>(ax1 bx1</tt><tt>)</tt>&rsquo;.  Then
</p>
<dl compact="compact">
<dt><tt>${(s/x/)foo}</tt></dt>
<dd><p>produces the words &lsquo;<tt>a</tt>&rsquo;, &lsquo;<tt>1 b</tt>&rsquo; and &lsquo;<tt>1</tt>&rsquo;.
</p>
</dd>
<dt><tt>${(j/x/s/x/)foo}</tt></dt>
<dd><p>produces &lsquo;<tt>a</tt>&rsquo;, &lsquo;<tt>1</tt>&rsquo;, &lsquo;<tt>b</tt>&rsquo; and &lsquo;<tt>1</tt>&rsquo;.
</p>
</dd>
<dt><tt>${(s/x/)foo%%1*}</tt></dt>
<dd><p>produces &lsquo;<tt>a</tt>&rsquo; and &lsquo;<tt> b</tt>&rsquo; (note the extra space).  As substitution
occurs before either joining or splitting, the operation  first generates
the modified array <tt>(ax bx</tt><tt>)</tt>, which is joined to give
<tt>&quot;ax bx&quot;</tt>, and then split to give &lsquo;<tt>a</tt>&rsquo;, &lsquo;<tt> b</tt>&rsquo; and &lsquo;&rsquo;.  The final
empty string will then be elided, as it is not in double quotes.
</p>
</dd>
</dl>

<hr>
<a name="Command-Substitution"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Examples" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Arithmetic-Expansion" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="Command-Substitution-1"></a>
<h2 class="section">14.4 Command Substitution</h2>
<a name="index-command-substitution"></a>
<a name="index-substitution_002c-command"></a>
<p>A command enclosed in parentheses preceded by a dollar sign, like
&lsquo;<tt>$(</tt>...<tt>)</tt>&rsquo;, or quoted with grave 
accents, like &lsquo;<tt>`</tt>...<tt>`</tt>&rsquo;, is replaced with its standard output, with
any trailing newlines deleted.
If the substitution is not enclosed in double quotes, the
output is broken into words using the <tt>IFS</tt> parameter.
<a name="index-IFS_002c-use-of-1"></a>
The substitution &lsquo;<tt>$(cat</tt> <var>foo</var><tt>)</tt>&rsquo; may be replaced
by the equivalent but faster &lsquo;<tt>$(&lt;</tt><var>foo</var><tt>)</tt>&rsquo;.
In either case, if the option <tt>GLOB_SUBST</tt> is set,
the output is eligible for filename generation.
</p><hr>
<a name="Arithmetic-Expansion"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Command-Substitution" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Brace-Expansion" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="Arithmetic-Expansion-1"></a>
<h2 class="section">14.5 Arithmetic Expansion</h2>
<a name="index-arithmetic-expansion"></a>
<a name="index-expansion_002c-arithmetic"></a>
<p>A string of the form &lsquo;<tt>$[</tt><var>exp</var><tt>]</tt>&rsquo; or
&lsquo;<tt>$((</tt><var>exp</var><tt>))</tt>&rsquo; is substituted
with the value of the arithmetic expression <var>exp</var>.  <var>exp</var> is
subjected to <em>parameter expansion</em>, <em>command substitution</em>
and <em>arithmetic expansion</em> before it is evaluated.
See <a href="Arithmetic-Evaluation.html#Arithmetic-Evaluation">Arithmetic Evaluation</a>.
</p><hr>
<a name="Brace-Expansion"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arithmetic-Expansion" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Expansion" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="Brace-Expansion-1"></a>
<h2 class="section">14.6 Brace Expansion</h2>
<a name="index-brace-expansion"></a>
<a name="index-expansion_002c-brace"></a>
<p>A string of the form
&lsquo;<var>foo</var><tt>{</tt><var>xx</var><tt>,</tt><var>yy</var><tt>,</tt><var>zz</var><tt>}</tt><var>bar</var>&rsquo;
is expanded to the individual words
&lsquo;<var>fooxxbar</var>&rsquo;, &lsquo;<var>fooyybar</var>&rsquo; and &lsquo;<var>foozzbar</var>&rsquo;.
Left-to-right order is preserved.  This construct
may be nested.  Commas may be quoted in order to
include them literally in a word.
</p>
<p>An expression of the form &lsquo;<tt>{</tt><var>n1</var><tt>..</tt><var>n2</var><tt>}</tt>&rsquo;,
where <var>n1</var> and <var>n2</var> are integers,
is expanded to every number between
<var>n1</var> and <var>n2</var> inclusive.  If either number begins with a
zero, all the resulting numbers will be padded with leading zeroes to
that minimum width, but for negative numbers the <tt>-</tt> character is also
included in the width.  If the numbers are in decreasing order the
resulting sequence will also be in decreasing order.
</p>
<p>An expression of the form &lsquo;<tt>{</tt><var>n1</var><tt>..</tt><var>n2</var><tt>..</tt><var>n3</var><tt>}</tt>&rsquo;,
where <var>n1</var>, <var>n2</var>, and <var>n3</var> are integers,
is expanded as above, but only every <var>n3</var>th number starting from <var>n1</var>
is output.  If <var>n3</var> is negative the numbers are output in reverse order,
this is slightly different from simply swapping <var>n1</var> and <var>n2</var> in the case
that the step <var>n3</var> doesn&rsquo;t evenly divide the range.  Zero padding can be
specified in any of the three numbers, specifying it in the third can be useful
to pad for example &lsquo;<tt>{-99..100..01}</tt>&rsquo; which is not possible to specify by putting a
0 on either of the first two numbers (i.e. pad to two characters).
</p>
<p>An expression of the form &lsquo;<tt>{</tt><var>c1</var><tt>..</tt><var>c2</var><tt>}</tt>&rsquo;, where
<var>c1</var> and <var>c2</var> are single characters (which may be multibyte
characters), is expanded to every character in the range from <var>c1</var> to
<var>c2</var> in whatever character sequence is used internally.  For
characters with code points below 128 this is US ASCII (this is the only
case most users will need).  If any intervening character is not
printable, appropriate quotation is used to render it printable.
If the character sequence is reversed, the output is in reverse
order, e.g. &lsquo;<tt>{d..a}</tt>&rsquo; is substituted as &lsquo;<tt>d c b a</tt>&rsquo;.
</p>
<p>If a brace expression matches none of the above forms, it is left
unchanged, unless the option <tt>BRACE_CCL</tt> (an abbreviation for &lsquo;brace
character class&rsquo;) is set.
<a name="index-BRACE_005fCCL_002c-use-of"></a>
In that case, it is expanded to a list of the individual
characters between the braces sorted into the order of the characters
in the ASCII character set (multibyte characters are not currently
handled).  The syntax is similar to a
<tt>[</tt>...<tt>]</tt> expression in filename generation:
&lsquo;<tt>-</tt>&rsquo; is treated specially to denote a range of characters, but &lsquo;<tt>^</tt>&rsquo; or
&lsquo;<tt>!</tt>&rsquo; as the first character is treated normally.  For example,
&lsquo;<tt>{abcdef0-9}</tt>&rsquo; expands to 16 words <tt>0 1 2 3 4 5 6 7 8 9 a b c d e f</tt>.
</p>
<p>Note that brace expansion is not part of filename generation (globbing); an
expression such as <tt>*/{foo,bar}</tt> is split into two separate words
<tt>*/foo</tt> and <tt>*/bar</tt> before filename generation takes place.  In
particular, note that this is liable to produce a &lsquo;no match&rsquo; error if
<em>either</em> of the two expressions does not match; this is to be contrasted
with <tt>*/(foo|bar)</tt>, which is treated as a single pattern but otherwise
has similar effects.
</p>
<p>To combine brace expansion with array expansion, see the
<tt>${^</tt><var>spec</var><tt>}</tt> form described
in <a href="#Parameter-Expansion">Parameter Expansion</a>
above.
</p>
<hr>
<a name="Filename-Expansion"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Brace-Expansion" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-named-directories" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="Filename-Expansion-1"></a>
<h2 class="section">14.7 Filename Expansion</h2>
<a name="index-filename-expansion"></a>
<a name="index-expansion_002c-filename"></a>
<p>Each word is checked to see if it begins with an unquoted &lsquo;<tt>~</tt>&rsquo;.
If it does, then the word up to a &lsquo;<tt>/</tt>&rsquo;,
or the end of the word if there is no &lsquo;<tt>/</tt>&rsquo;,
is checked to see if it can be substituted in one of the ways
described here.  If so, then the &lsquo;<tt>~</tt>&rsquo; and the checked portion are
replaced with the appropriate substitute value.
</p>
<p>A &lsquo;<tt>~</tt>&rsquo; by itself is replaced by the value of <tt>$HOME</tt>.
A &lsquo;<tt>~</tt>&rsquo; followed by a &lsquo;<tt>+</tt>&rsquo; or a &lsquo;<tt>-</tt>&rsquo; is replaced by current
or previous working directory, respectively.
</p>
<p>A &lsquo;<tt>~</tt>&rsquo; followed by a number is replaced by the directory at that
position in the directory stack.
&lsquo;<tt>~0</tt>&rsquo; is equivalent to &lsquo;<tt>~+</tt>&rsquo;,
and &lsquo;<tt>~1</tt>&rsquo; is the top of the stack.
&lsquo;<tt>~+</tt>&rsquo; followed by a number is replaced by the directory at that
position in the directory stack.
&lsquo;<tt>~+0</tt>&rsquo; is equivalent to &lsquo;<tt>~+</tt>&rsquo;,
and &lsquo;<tt>~+1</tt>&rsquo; is the top of the stack.
&lsquo;<tt>~-</tt>&rsquo; followed by a number is replaced by the directory that
many positions from the bottom of the stack.
&lsquo;<tt>~-0</tt>&rsquo; is the bottom of the stack.
<a name="index-PUSHD_005fMINUS_002c-use-of"></a>
The <tt>PUSHD_MINUS</tt>
option exchanges the effects of &lsquo;<tt>~+</tt>&rsquo; and &lsquo;<tt>~-</tt>&rsquo; where they are
followed by a number.
</p>

<hr>
<a name="Dynamic-named-directories"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Expansion" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Static-named-directories" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.7.1 Dynamic named directories</h3>
<a name="index-directories_002c-named_002c-dynamic"></a>
<a name="index-named-directories_002c-dynamic"></a>
<a name="index-dynamic-named-directories"></a>

<p>If the function <tt>zsh_directory_name</tt> exists, or the shell variable
<tt>zsh_directory_name_functions</tt> exists and contains an array of
function names, then the functions are used to implement dynamic
directory naming.  The functions are tried in order until one returns
status zero, so it is important that functions test whether they can
handle the case in question and return an appropriate status.
</p>
<p>A &lsquo;<tt>~</tt>&rsquo; followed by a string <var>namstr</var> in unquoted square brackets is
treated specially as a dynamic directory name.  Note that the first
unquoted closing square bracket always terminates <var>namstr</var>.  The shell
function is passed two arguments: the string <tt>n</tt> (for name) and
<var>namstr</var>.  It should either set the array <tt>reply</tt> to a single element
which is the directory corresponding to the name and return status zero
(executing an assignment as the last statement is usually sufficient), or
it should return status non-zero.  In the former case the element of reply
is used as the directory; in the latter case the substitution is deemed to
have failed.  If all functions fail and the option <tt>NOMATCH</tt> is set,
an error results.
</p>
<p>The functions defined as above are also used to see if a directory can
be turned into a name, for example when printing the directory stack or
when expanding <tt>%~</tt> in prompts.  In this case each function is passed two
arguments: the string <tt>d</tt> (for directory) and the candidate for dynamic
naming.  The function should either return non-zero status, if the
directory cannot be named by the function, or it should set the array reply
to consist of two elements: the first is the dynamic name for the directory
(as would appear within &lsquo;<tt>~[</tt><var>...</var><tt>]</tt>&rsquo;), and the second is the
prefix length of the directory to be replaced.  For example, if the trial
directory is <tt>/home/myname/src/zsh</tt> and the dynamic name for
<tt>/home/myname/src</tt> (which has 16 characters) is <tt>s</tt>, then the function
sets
</p>
<div class="example">
<pre class="example">reply=(s 16)
</pre></div>

<p>The directory name so returned is compared with possible static names for
parts of the directory path, as described below; it is used if the prefix
length matched (16 in the example) is longer than that matched by any
static name.
</p>
<p>It is not a requirement that a function implements both
<tt>n</tt> and <tt>d</tt> calls; for example, it might be appropriate for certain
dynamic forms of expansion not to be contracted to names.  In that case
any call with the first argument <tt>d</tt> should cause a non-zero status to
be returned.
</p>
<p>The completion system calls &lsquo;<tt>zsh_directory_name c</tt>&rsquo; followed by
equivalent calls to elements of the array
<tt>zsh_directory_name_functions</tt>, if it exists, in order to
complete dynamic names for directories.  The code for this should be
as for any other completion function as described in
<a href="Completion-System.html#Completion-System">Completion System</a>.
</p>
<p>As a working example, here is a function that expands any dynamic names
beginning with the string <tt>p:</tt> to directories below
<tt>/home/pws/perforce</tt>.  In this simple case a static name for the
directory would be just as effective.
</p>
<div class="example">
<pre class="example">zsh_directory_name() {
  emulate -L zsh
  setopt extendedglob
  local -a match mbegin mend
  if [[ $1 = d ]]; then
    # turn the directory into a name
    if [[ $2 = (#b)(/home/pws/perforce/)([^/]##)* ]]; then
      typeset -ga reply
      reply=(p:$match[2] $(( ${#match[1]} + ${#match[2]} )) )
    else
      return 1
    fi
  elif [[ $1 = n ]]; then
    # turn the name into a directory
    [[ $2 != (#b)p:(?*) ]] &amp;&amp; return 1
    typeset -ga reply
    reply=(/home/pws/perforce/$match[1])
  elif [[ $1 = c ]]; then
    # complete names
    local expl
    local -a dirs
    dirs=(/home/pws/perforce/*(/:t))
    dirs=(p:${^dirs})
    _wanted dynamic-dirs expl 'dynamic directory' compadd -S\] -a dirs
    return
  else
    return 1
  fi
  return 0
}
</pre></div>


<hr>
<a name="Static-named-directories"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-named-directories" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#g_t_0060_003d_0027-expansion" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.7.2 Static named directories</h3>
<a name="index-directories_002c-named_002c-static"></a>
<a name="index-named-directories_002c-static"></a>
<a name="index-static-named-directories"></a>
<p>A &lsquo;<tt>~</tt>&rsquo; followed by anything not already covered consisting
of any number of alphanumeric characters or underscore (&lsquo;<tt>_</tt>&rsquo;),
hyphen (&lsquo;<tt>-</tt>&rsquo;), or dot (&lsquo;<tt>.</tt>&rsquo;) is looked up as a
named directory, and replaced by the value of that named directory if found.
Named directories are typically home directories for users on the system.
They may also be defined if the text after the &lsquo;<tt>~</tt>&rsquo; is the name
of a string shell parameter whose value begins with a &lsquo;<tt>/</tt>&rsquo;.
Note that trailing slashes will be removed from the path to the directory
(though the original parameter is not modified).
</p>
<p>It is also possible to define directory names using the <tt>-d</tt> option to the
<tt>hash</tt> builtin.
</p>
<p>When the shell prints a path (e.g. when expanding <tt>%~</tt> in prompts or when
printing the directory stack), the path is checked to see if it has a named
directory as its prefix.  If so, then the prefix portion is replaced with a
&lsquo;<tt>~</tt>&rsquo; followed by the name of the directory.
The shorter of the two ways of referring to the directory is used,
i.e. either the directory name or the full path; the name is used
if they are the same length.
The parameters <tt>$PWD</tt> and <tt>$OLDPWD</tt> are never abbreviated in this fashion.
</p>

<hr>
<a name="g_t_0060_003d_0027-expansion"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Static-named-directories" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.7.3 &lsquo;=&rsquo; expansion</h3>

<p>If a word begins with an unquoted &lsquo;<tt>=</tt>&rsquo;
and the <tt>EQUALS</tt> option is set,
the remainder of the word is taken as the
name of a command.  If a command
exists by that name, the word is replaced
by the full pathname of the command.
</p>

<hr>
<a name="Notes"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#g_t_0060_003d_0027-expansion" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Generation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.7.4 Notes</h3>

<p>Filename expansion is performed on the right hand side of a parameter
assignment, including those appearing after commands of the
<tt>typeset</tt> family.  In this case, the right hand side will be treated
as a colon-separated list in the manner of the <tt>PATH</tt> parameter,
so that a &lsquo;<tt>~</tt>&rsquo; or an &lsquo;<tt>=</tt>&rsquo; following a &lsquo;<tt>:</tt>&rsquo; is eligible for expansion.
All such behaviour can be
disabled by quoting the &lsquo;<tt>~</tt>&rsquo;, the &lsquo;<tt>=</tt>&rsquo;, or the whole expression (but not
simply the colon); the <tt>EQUALS</tt> option is also respected.
</p>
<p>If the option <tt>MAGIC_EQUAL_SUBST</tt> is set, any unquoted shell
argument in the form &lsquo;<var>identifier</var><tt>=</tt><var>expression</var>&rsquo; becomes eligible
for file expansion as described in the previous paragraph.  Quoting the
first &lsquo;<tt>=</tt>&rsquo; also inhibits this.
</p>
<hr>
<a name="Filename-Generation"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expansion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Glob-Operators" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="Filename-Generation-1"></a>
<h2 class="section">14.8 Filename Generation</h2>
<a name="index-filename-generation"></a>
<p>If a word contains an unquoted instance of one of the characters
&lsquo;<tt>*</tt>&rsquo;, &lsquo;<tt>(</tt>&rsquo;, &lsquo;<tt>|</tt>&rsquo;, &lsquo;<tt>&lt;</tt>&rsquo;, &lsquo;<tt>[</tt>&rsquo;, or &lsquo;<tt>?</tt>&rsquo;, it is regarded
as a pattern for filename generation, unless the <tt>GLOB</tt> option is unset.
<a name="index-GLOB_002c-use-of"></a>
If the <tt>EXTENDED_GLOB</tt> option is set,
<a name="index-EXTENDED_005fGLOB_002c-use-of"></a>
the &lsquo;<tt>^</tt>&rsquo; and &lsquo;<tt>#</tt>&rsquo; characters also denote a pattern; otherwise
they are not treated specially by the shell.
</p>
<p>The word is replaced with a list of sorted filenames that match
the pattern.  If no matching pattern is found, the shell gives
an error message, unless the <tt>NULL_GLOB</tt> option is set,
<a name="index-NULL_005fGLOB_002c-use-of"></a>
in which case the word is deleted; or unless the <tt>NOMATCH</tt>
option is unset, in which case the word is left unchanged.
<a name="index-NOMATCH_002c-use-of"></a>
</p>
<p>In filename generation,
the character &lsquo;<tt>/</tt>&rsquo; must be matched explicitly;
also, a &lsquo;<tt>.</tt>&rsquo; must be matched
explicitly at the beginning of a pattern or after a &lsquo;<tt>/</tt>&rsquo;, unless the
<tt>GLOB_DOTS</tt> option is set.
<a name="index-GLOB_005fDOTS_002c-use-of"></a>
No filename generation pattern
matches the files &lsquo;<tt>.</tt>&rsquo; or &lsquo;<tt>..</tt>&rsquo;.  In other instances of pattern
matching, the &lsquo;<tt>/</tt>&rsquo; and &lsquo;<tt>.</tt>&rsquo; are not treated specially.
</p>
<hr>
<a name="Glob-Operators"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Generation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Generation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#ksh_002dlike-Glob-Operators" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.8.1 Glob Operators</h3>
<dl compact="compact">
<dt><tt>*</tt></dt>
<dd><p>Matches any string, including the null string.
</p>
</dd>
<dt><tt>?</tt></dt>
<dd><p>Matches any character.
</p>
</dd>
<dt><tt>[</tt>...<tt>]</tt></dt>
<dd><p>Matches any of the enclosed characters.  Ranges of characters
can be specified by separating two characters by a &lsquo;<tt>-</tt>&rsquo;.
A &lsquo;<tt>-</tt>&rsquo; or &lsquo;<tt>]</tt>&rsquo; may be matched by including it as the
first character in the list.
<a name="index-character-classes"></a>
There are also several named classes of characters, in the form
&lsquo;<tt>[:</tt><var>name</var><tt>:]</tt>&rsquo; with the following meanings.
The first set use the macros provided by
the operating system to test for the given character combinations,
including any modifications due to local language settings, see
man page ctype(3):
</p>
<dl compact="compact">
<dt><tt>[:alnum:]</tt></dt>
<dd><p>The character is alphanumeric
</p>
</dd>
<dt><tt>[:alpha:]</tt></dt>
<dd><p>The character is alphabetic
</p>
</dd>
<dt><tt>[:ascii:]</tt></dt>
<dd><p>The character is 7-bit, i.e. is a single-byte character without
the top bit set.
</p>
</dd>
<dt><tt>[:blank:]</tt></dt>
<dd><p>The character is either space or tab
</p>
</dd>
<dt><tt>[:cntrl:]</tt></dt>
<dd><p>The character is a control character
</p>
</dd>
<dt><tt>[:digit:]</tt></dt>
<dd><p>The character is a decimal digit
</p>
</dd>
<dt><tt>[:graph:]</tt></dt>
<dd><p>The character is a printable character other than whitespace
</p>
</dd>
<dt><tt>[:lower:]</tt></dt>
<dd><p>The character is a lowercase letter
</p>
</dd>
<dt><tt>[:print:]</tt></dt>
<dd><p>The character is printable
</p>
</dd>
<dt><tt>[:punct:]</tt></dt>
<dd><p>The character is printable but neither alphanumeric nor whitespace
</p>
</dd>
<dt><tt>[:space:]</tt></dt>
<dd><p>The character is whitespace
</p>
</dd>
<dt><tt>[:upper:]</tt></dt>
<dd><p>The character is an uppercase letter
</p>
</dd>
<dt><tt>[:xdigit:]</tt></dt>
<dd><p>The character is a hexadecimal digit
</p>
</dd>
</dl>

<p>Another set of named classes is handled internally by the shell and
is not sensitive to the locale:
</p>
<dl compact="compact">
<dt><tt>[:IDENT:]</tt></dt>
<dd><p>The character is allowed to form part of a shell identifier, such
as a parameter name
</p>
</dd>
<dt><tt>[:IFS:]</tt></dt>
<dd><p>The character is used as an input field separator, i.e. is contained in the
<tt>IFS</tt> parameter
</p>
</dd>
<dt><tt>[:IFSSPACE:]</tt></dt>
<dd><p>The character is an IFS white space character; see the documentation
for <tt>IFS</tt> in
<a href="Parameters.html#Parameters-Used-By-The-Shell">Parameters Used By The Shell</a>.
</p>
</dd>
<dt><tt>[:INCOMPLETE:]</tt></dt>
<dd><p>Matches a byte that starts an incomplete multibyte character.
Note that there may be a sequence of more than one bytes that
taken together form the prefix of a multibyte character.  To
test for a potentially incomplete byte sequence, use the pattern
&lsquo;<tt>[[:INCOMPLETE:]]*</tt>&rsquo;.  This will never match a sequence starting
with a valid multibyte character.
</p>
</dd>
<dt><tt>[:INVALID:]</tt></dt>
<dd><p>Matches a byte that does not start a valid multibyte character.
Note this may be a continuation byte of an incomplete multibyte
character as any part of a multibyte string consisting of invalid and
incomplete multibyte characters is treated as single bytes.
</p>
</dd>
<dt><tt>[:WORD:]</tt></dt>
<dd><p>The character is treated as part of a word; this test is sensitive
to the value of the <tt>WORDCHARS</tt> parameter
</p>
</dd>
</dl>

<p>Note that the square brackets are additional
to those enclosing the whole set of characters, so to test for a
single alphanumeric character you need &lsquo;<tt>[[:alnum:]]</tt>&rsquo;.  Named
character sets can be used alongside other types,
e.g. &lsquo;<tt>[[:alpha:]0-9]</tt>&rsquo;.
</p>
</dd>
<dt><tt>[^</tt>...<tt>]</tt></dt>
<dt><tt>[!</tt>...<tt>]</tt></dt>
<dd><p>Like <tt>[</tt>...<tt>]</tt>, except that it matches any character which is
not in the given set.
</p>
</dd>
<dt><tt>&lt;</tt>[<var>x</var>]<tt>-</tt>[<var>y</var>]<tt>&gt;</tt></dt>
<dd><p>Matches any number in the range <var>x</var> to <var>y</var>, inclusive.
Either of the numbers may be omitted to make the range open-ended;
hence &lsquo;<tt>&lt;-&gt;</tt>&rsquo; matches any number.  To match individual digits, the
<tt>[</tt>...<tt>]</tt> form is more efficient.
</p>
<p>Be careful when using other wildcards adjacent to patterns of this form;
for example, <tt>&lt;0-9&gt;*</tt> will actually match any number whatsoever at the
start of the string, since the &lsquo;<tt>&lt;0-9&gt;</tt>&rsquo; will match the first digit, and
the &lsquo;<tt>*</tt>&rsquo; will match any others.  This is a trap for the unwary, but is
in fact an inevitable consequence of the rule that the longest possible
match always succeeds.  Expressions such as &lsquo;<tt>&lt;0-9&gt;[^[:digit:]]*</tt>&rsquo; can be
used instead.
</p>
</dd>
<dt><tt>(</tt>...<tt>)</tt></dt>
<dd><p>Matches the enclosed pattern.  This is used for grouping.
If the <tt>KSH_GLOB</tt> option is set, then a
&lsquo;<tt>@</tt>&rsquo;, &lsquo;<tt>*</tt>&rsquo;, &lsquo;<tt>+</tt>&rsquo;, &lsquo;<tt>?</tt>&rsquo; or &lsquo;<tt>!</tt>&rsquo; immediately preceding
the &lsquo;<tt>(</tt>&rsquo; is treated specially, as detailed below. The option
<tt>SH_GLOB</tt> prevents bare parentheses from being used in this way, though
the <tt>KSH_GLOB</tt> option is still available.
</p>
<p>Note that grouping cannot extend over multiple directories: it is an error
to have a &lsquo;<tt>/</tt>&rsquo; within a group (this only applies for patterns used in
filename generation).  There is one exception:  a group of the form
<tt>(</tt><var>pat</var><tt>/)#</tt> appearing as a complete path segment can
match a sequence of directories.  For example, <tt>foo/(a*/)#bar</tt> matches
<tt>foo/bar</tt>, <tt>foo/any/bar</tt>, <tt>foo/any/anyother/bar</tt>, and so on.
</p>
</dd>
<dt><var>x</var><tt>|</tt><var>y</var></dt>
<dd><p>Matches either <var>x</var> or <var>y</var>.
This operator has lower precedence than any other.
The &lsquo;<tt>|</tt>&rsquo; character
must be within parentheses, to avoid interpretation as a pipeline.
The alternatives are tried in order from left to right.
</p>
</dd>
<dt><tt>^</tt><var>x</var></dt>
<dd><p>(Requires <tt>EXTENDED_GLOB</tt> to be set.)
Matches anything except the pattern <var>x</var>.
This has a higher precedence than &lsquo;<tt>/</tt>&rsquo;, so &lsquo;<tt>^foo/bar</tt>&rsquo;
will search directories in &lsquo;<tt>.</tt>&rsquo; except &lsquo;<tt>./foo</tt>&rsquo;
for a file named &lsquo;<tt>bar</tt>&rsquo;.
</p>
</dd>
<dt><var>x</var><tt>~</tt><var>y</var></dt>
<dd><p>(Requires <tt>EXTENDED_GLOB</tt> to be set.)
Match anything that matches the pattern <var>x</var> but does not match <var>y</var>.
This has lower precedence than any operator except &lsquo;<tt>|</tt>&rsquo;, so
&lsquo;<tt>*/*~foo/bar</tt>&rsquo; will search for all files in all directories in &lsquo;<tt>.</tt>&rsquo;
and then exclude &lsquo;<tt>foo/bar</tt>&rsquo; if there was such a match.
Multiple patterns can be excluded by
&lsquo;<var>foo</var><tt>~</tt><var>bar</var><tt>~</tt><var>baz</var>&rsquo;.
In the exclusion pattern (<var>y</var>), &lsquo;<tt>/</tt>&rsquo; and &lsquo;<tt>.</tt>&rsquo; are not treated
specially the way they usually are in globbing.
</p>
</dd>
<dt><var>x</var><tt>#</tt></dt>
<dd><p>(Requires <tt>EXTENDED_GLOB</tt> to be set.)
Matches zero or more occurrences of the pattern <var>x</var>.
This operator has high precedence; &lsquo;<tt>12#</tt>&rsquo; is equivalent to &lsquo;<tt>1(2#)</tt>&rsquo;,
rather than &lsquo;<tt>(12)#</tt>&rsquo;.  It is an error for an unquoted &lsquo;<tt>#</tt>&rsquo; to follow
something which cannot be repeated; this includes an empty string, a
pattern already followed by &lsquo;<tt>##</tt>&rsquo;, or parentheses when part of a
<tt>KSH_GLOB</tt> pattern (for example, &lsquo;<tt>!(</tt><var>foo</var><tt>)#</tt>&rsquo; is
invalid and must be replaced by
&lsquo;<tt>*(!(</tt><var>foo</var><tt>))</tt>&rsquo;).
</p>
</dd>
<dt><var>x</var><tt>##</tt></dt>
<dd><p>(Requires <tt>EXTENDED_GLOB</tt> to be set.)
Matches one or more occurrences of the pattern <var>x</var>.
This operator has high precedence; &lsquo;<tt>12##</tt>&rsquo; is equivalent to &lsquo;<tt>1(2##)</tt>&rsquo;,
rather than &lsquo;<tt>(12)##</tt>&rsquo;.  No more than two active &lsquo;<tt>#</tt>&rsquo; characters may
appear together.  (Note the potential clash with glob qualifiers in the
form &lsquo;<tt>1(2##)</tt>&rsquo; which should therefore be avoided.)
</p>
</dd>
</dl>

<hr>
<a name="ksh_002dlike-Glob-Operators"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Glob-Operators" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Generation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Precedence" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.8.2 ksh-like Glob Operators</h3>
<a name="index-KSH_005fGLOB_002c-use-of"></a>
<p>If the <tt>KSH_GLOB</tt> option is set, the effects of parentheses can be
modified by a preceding &lsquo;<tt>@</tt>&rsquo;, &lsquo;<tt>*</tt>&rsquo;, &lsquo;<tt>+</tt>&rsquo;, &lsquo;<tt>?</tt>&rsquo; or &lsquo;<tt>!</tt>&rsquo;.
This character need not be unquoted to have special effects,
but the &lsquo;<tt>(</tt>&rsquo; must be.
</p>
<dl compact="compact">
<dt><tt>@(</tt>...<tt>)</tt></dt>
<dd><p>Match the pattern in the parentheses.  (Like &lsquo;<tt>(</tt>...<tt>)</tt>&rsquo;.)
</p>
</dd>
<dt><tt>*(</tt>...<tt>)</tt></dt>
<dd><p>Match any number of occurrences.  (Like &lsquo;<tt>(</tt>...<tt>)#</tt>&rsquo;,
except that recursive directory searching is not supported.)
</p>
</dd>
<dt><tt>+(</tt>...<tt>)</tt></dt>
<dd><p>Match at least one occurrence.  (Like &lsquo;<tt>(</tt>...<tt>)##</tt>&rsquo;,
except that recursive directory searching is not supported.)
</p>
</dd>
<dt><tt>?(</tt>...<tt>)</tt></dt>
<dd><p>Match zero or one occurrence.  (Like &lsquo;<tt>(|</tt>...<tt>)</tt>&rsquo;.)
</p>
</dd>
<dt><tt>!(</tt>...<tt>)</tt></dt>
<dd><p>Match anything but the expression in parentheses.
(Like &lsquo;<tt>(^(</tt>...<tt>))</tt>&rsquo;.)
</p>
</dd>
</dl>

<hr>
<a name="Precedence"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#ksh_002dlike-Glob-Operators" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Generation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Globbing-Flags" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.8.3 Precedence</h3>
<a name="index-precedence-of-glob-operators"></a>
<p>The precedence of the operators given above is (highest) &lsquo;<tt>^</tt>&rsquo;, &lsquo;<tt>/</tt>&rsquo;,
&lsquo;<tt>~</tt>&rsquo;, &lsquo;<tt>|</tt>&rsquo; (lowest); the
remaining operators are simply treated from left to right as part of a
string, with &lsquo;<tt>#</tt>&rsquo; and &lsquo;<tt>##</tt>&rsquo; applying to the shortest possible
preceding unit (i.e. a character, &lsquo;<tt>?</tt>&rsquo;, &lsquo;<tt>[</tt>...<tt>]</tt>&rsquo;,
&lsquo;<tt>&lt;</tt>...<tt>&gt;</tt>&rsquo;, or a parenthesised expression).  As mentioned
above, a &lsquo;<tt>/</tt>&rsquo; used as a directory separator may not appear inside
parentheses, while a &lsquo;<tt>|</tt>&rsquo; must do so; in patterns used in other contexts
than filename generation (for example, in <tt>case</tt> statements and tests
within &lsquo;<tt>[[</tt>...<tt>]]</tt>&rsquo;), a &lsquo;<tt>/</tt>&rsquo; is not special; and &lsquo;<tt>/</tt>&rsquo; is also
not special after a &lsquo;<tt>~</tt>&rsquo; appearing outside parentheses in a filename
pattern.
</p>
<hr>
<a name="Globbing-Flags"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Precedence" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Generation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Approximate-Matching" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.8.4 Globbing Flags</h3>
<p>There are various flags which affect any text to their right up to the
end of the enclosing group or to the end of the pattern; they require
the <tt>EXTENDED_GLOB</tt> option. All take the form
<tt>(#</tt><var>X</var><tt>)</tt> where <var>X</var> may have one of the following
forms:
</p>
<dl compact="compact">
<dt><tt>i</tt></dt>
<dd><p>Case insensitive:  upper or lower case characters in the pattern match
upper or lower case characters.
</p>
</dd>
<dt><tt>l</tt></dt>
<dd><p>Lower case characters in the pattern match upper or lower case
characters; upper case characters in the pattern still only match
upper case characters.
</p>
</dd>
<dt><tt>I</tt></dt>
<dd><p>Case sensitive:  locally negates the effect of <tt>i</tt> or <tt>l</tt> from
that point on.
</p>
<a name="index-match"></a>
<a name="index-mbegin"></a>
<a name="index-mend"></a>
</dd>
<dt><tt>b</tt></dt>
<dd><p>Activate backreferences for parenthesised groups in the pattern;
this does not work in filename generation.  When a pattern with a set of
active parentheses is matched, the strings matched by the groups are
stored in the array <tt>$match</tt>, the indices of the beginning of the matched
parentheses in the array <tt>$mbegin</tt>, and the indices of the end in the array
<tt>$mend</tt>, with the first element of each array corresponding to the first
parenthesised group, and so on.  These arrays are not otherwise special to
the shell.  The indices use the same convention as does parameter
substitution, so that elements of <tt>$mend</tt> and <tt>$mbegin</tt> may be used in
subscripts; the <tt>KSH_ARRAYS</tt> option is respected.  Sets of globbing flags
are not considered parenthesised groups; only the first nine active
parentheses can be referenced.
</p>
<p>For example,
</p>
<div class="example">
<pre class="example">foo=&quot;a string with a message&quot;
if [[ $foo = (a|an)' '(#b)(*)' '* ]]; then
  print ${foo[$mbegin[1],$mend[1]]}
fi
</pre></div>

<p>prints &lsquo;<tt>string with a</tt>&rsquo;.  Note that the first parenthesis is before the
<tt>(#b)</tt> and does not create a backreference.
</p>
<p>Backreferences work with all forms of pattern matching other than filename
generation, but note that when performing matches on an entire array, such
as <tt>${</tt><var>array</var><tt>#</tt><var>pattern</var><tt>}</tt>, or a global substitution, such
as <tt>${</tt><var>param</var><tt>//</tt><var>pat</var><tt>/</tt><var>repl</var><tt>}</tt>, only the data for the
last match remains available.  In the case of global replacements this may
still be useful.  See the example for the <tt>m</tt> flag below.
</p>
<p>The numbering of backreferences strictly follows the order of the opening
parentheses from left to right in the pattern string, although sets of
parentheses may be nested.  There are special rules for parentheses followed
by &lsquo;<tt>#</tt>&rsquo; or &lsquo;<tt>##</tt>&rsquo;.  Only the last match of the parenthesis is
remembered: for example, in &lsquo;<tt>[[ abab = (#b)([ab])# ]]</tt>&rsquo;, only the final
&lsquo;<tt>b</tt>&rsquo; is stored in <tt>match[1]</tt>.  Thus extra parentheses may be necessary
to match the complete segment: for example, use
&lsquo;<tt>X((ab|cd)#)Y</tt>&rsquo; to match
a whole string of either &lsquo;<tt>ab</tt>&rsquo; or &lsquo;<tt>cd</tt>&rsquo; between &lsquo;<tt>X</tt>&rsquo; and &lsquo;<tt>Y</tt>&rsquo;,
using the value of <tt>$match[1]</tt> rather than <tt>$match[2]</tt>.
</p>
<p>If the match fails none of the parameters is altered, so in some cases it
may be necessary to initialise them beforehand.  If some of the
backreferences fail to match &mdash; which happens if they are in an alternate
branch which fails to match, or if they are followed by <tt>#</tt> and matched
zero times &mdash; then the matched string is set to the empty string, and the
start and end indices are set to -1.
</p>
<p>Pattern matching with backreferences is slightly slower than without.
</p>
</dd>
<dt><tt>B</tt></dt>
<dd><p>Deactivate backreferences, negating the effect of the <tt>b</tt> flag from that
point on.
</p>
</dd>
<dt><tt>c</tt><var>N</var><tt>,</tt><var>M</var></dt>
<dd><p>The flag <tt>(#c</tt><var>N</var><tt>,</tt><var>M</var><tt>)</tt> can be used anywhere
that the <tt>#</tt> or <tt>##</tt> operators can be used except in the expressions
&lsquo;<tt>(*/)#</tt>&rsquo; and &lsquo;<tt>(*/)##</tt>&rsquo; in filename generation, where &lsquo;<tt>/</tt>&rsquo;
has special meaning; it cannot be combined with other globbing flags and
a bad pattern error occurs if it is misplaced.  It is equivalent to the
form <tt>{</tt><var>N</var><tt>,</tt><var>M</var><tt>}</tt> in regular expressions.  The previous
character or group is required to match between <var>N</var> and <var>M</var> times,
inclusive.  The form <tt>(#c</tt><var>N</var><tt>)</tt> requires exactly <tt>N</tt>
matches; <tt>(#c,</tt><var>M</var><tt>)</tt> is equivalent to specifying <var>N</var>
as 0; <tt>(#c</tt><var>N</var><tt>,)</tt> specifies that there is no maximum
limit on the number of matches.
</p>
<a name="index-MATCH"></a>
<a name="index-MBEGIN"></a>
<a name="index-MEND"></a>
</dd>
<dt><tt>m</tt></dt>
<dd><p>Set references to the match data for the entire string matched; this is
similar to backreferencing and does not work in filename generation.  The
flag must be in effect at the end of the pattern, i.e. not local to a
group. The parameters <tt>$MATCH</tt>,  <tt>$MBEGIN</tt> and <tt>$MEND</tt> will be set to
the string matched and to the indices of the beginning and end of the
string, respectively.  This is most useful in parameter substitutions, as
otherwise the string matched is obvious.
</p>
<p>For example,
</p>
<div class="example">
<pre class="example">arr=(veldt jynx grimps waqf zho buck)
print ${arr//(#m)[aeiou]/${(U)MATCH}}
</pre></div>

<p>forces all the matches (i.e. all vowels) into uppercase, printing
&lsquo;<tt>vEldt jynx grImps wAqf zhO bUck</tt>&rsquo;.
</p>
<p>Unlike backreferences, there is no speed penalty for using match
references, other than the extra substitutions required for the
replacement strings in cases such as the example shown.
</p>
</dd>
<dt><tt>M</tt></dt>
<dd><p>Deactivate the <tt>m</tt> flag, hence no references to match data will be
created.
</p>
</dd>
<dt><tt>a</tt><var>num</var></dt>
<dd><p>Approximate matching: <var>num</var> errors are allowed in the string matched by
the pattern.  The rules for this are described in the next subsection.
</p>
</dd>
<dt><tt>s</tt>, <tt>e</tt></dt>
<dd><p>Unlike the other flags, these have only a local effect, and each must
appear on its own:  &lsquo;<tt>(#s)</tt>&rsquo; and &lsquo;<tt>(#e)</tt>&rsquo; are the only valid forms.
The &lsquo;<tt>(#s)</tt>&rsquo; flag succeeds only at the start of the test string, and the
&lsquo;<tt>(#e)</tt>&rsquo; flag succeeds only at the end of the test string; they
correspond to &lsquo;<tt>^</tt>&rsquo; and &lsquo;<tt>$</tt>&rsquo; in standard regular expressions.  They
are useful for matching path segments in patterns other than those in
filename generation (where path segments are in any case treated
separately).  For example, &lsquo;<tt>*((#s)|/)test((#e)|/)*</tt>&rsquo; matches
a path segment &lsquo;<tt>test</tt>&rsquo; in any of the following strings: <tt>test</tt>,
<tt>test/at/start</tt>, <tt>at/end/test</tt>, <tt>in/test/middle</tt>.
</p>
<p>Another use is in parameter substitution; for example
&lsquo;<tt>${array/(#s)A*Z(#e)}</tt>&rsquo; will remove only elements of an
array which
match the complete pattern &lsquo;<tt>A*Z</tt>&rsquo;.  There are other ways of performing
many operations of this type, however the combination of the substitution
operations &lsquo;<tt>/</tt>&rsquo; and &lsquo;<tt>//</tt>&rsquo; with the &lsquo;<tt>(#s)</tt>&rsquo; and &lsquo;<tt>(#e)</tt>&rsquo; flags
provides a single simple and memorable method.
</p>
<p>Note that assertions of the form &lsquo;<tt>(^(#s))</tt>&rsquo; also work, i.e. match
anywhere except at the start of the string, although this actually means
&lsquo;anything except a zero-length portion at the start of the string&rsquo;; you
need to use &lsquo;<tt>(&quot;&quot;~(#s))</tt>&rsquo; to match a zero-length portion of the string
not at the start.
</p>
</dd>
<dt><tt>q</tt></dt>
<dd><p>A &lsquo;<tt>q</tt>&rsquo; and everything up to the closing parenthesis of the globbing
flags are ignored by the pattern matching code.  This is intended to
support the use of glob qualifiers, see below.  The result is that
the pattern &lsquo;<tt>(#b)(*).c(#q.)</tt>&rsquo; can be used both for globbing
and for
matching against a string.  In the former case, the &lsquo;<tt>(#q.)</tt>&rsquo; will be
treated as a glob qualifier and the &lsquo;<tt>(#b)</tt>&rsquo; will not be useful, while in
the latter case the &lsquo;<tt>(#b)</tt>&rsquo; is useful for backreferences and the
&lsquo;<tt>(#q.)</tt>&rsquo; will be ignored.  Note that colon modifiers in the glob
qualifiers are also not applied in ordinary pattern matching.
</p>
</dd>
<dt><tt>u</tt></dt>
<dd><p>Respect the current locale in determining the presence of multibyte
characters in a pattern, provided the shell was compiled with 
<tt>MULTIBYTE_SUPPORT</tt>.  This overrides the <tt>MULTIBYTE</tt>
option; the default behaviour is taken from the option.  Compare <tt>U</tt>.
(Mnemonic: typically multibyte characters are from Unicode in the UTF-8
encoding, although any extension of ASCII supported by the system
library may be used.)
</p>
</dd>
<dt><tt>U</tt></dt>
<dd><p>All characters are considered to be a single byte long.  The opposite
of <tt>u</tt>.  This overrides the <tt>MULTIBYTE</tt> option.
</p>
</dd>
</dl>

<p>For example, the test string <tt>fooxx</tt> can be matched by the pattern
<tt>(#i</tt><tt>)FOOXX</tt>, but not by <tt>(#l</tt><tt>)FOOXX</tt>,
<tt>(#i</tt><tt>)FOO</tt><tt>(#I</tt><tt>)XX</tt> or
<tt>((#i</tt><tt>)FOOX</tt><tt>)X</tt>.  The string
<tt>(#ia2</tt><tt>)readme</tt> specifies case-insensitive matching of
<tt>readme</tt> with up to two errors.
</p>
<p>When using the ksh syntax for grouping both <tt>KSH_GLOB</tt> and
<tt>EXTENDED_GLOB</tt> must be set and the left parenthesis should be
preceded by <tt>@</tt>.  Note also that the flags do not affect letters
inside <tt>[</tt>...<tt>]</tt> groups, in other words <tt>(#i</tt><tt>)[a-z]</tt>
still matches only lowercase letters.  Finally, note that when
examining whole paths case-insensitively every directory must be
searched for all files which match, so that a pattern of the form
<tt>(#i</tt><tt>)/foo/bar/...</tt> is potentially slow.
</p>

<hr>
<a name="Approximate-Matching"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Globbing-Flags" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Generation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Recursive-Globbing" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.8.5 Approximate Matching</h3>
<p>When matching approximately, the shell keeps a count of the errors found,
which cannot exceed the number specified in the
<tt>(#a</tt><var>num</var><tt>)</tt> flags.  Four types of error are recognised:
</p>
<dl compact="compact">
<dt>1.</dt>
<dd><p>Different characters, as in <tt>fooxbar</tt> and <tt>fooybar</tt>.
</p>
</dd>
<dt>2.</dt>
<dd><p>Transposition of characters, as in <tt>banana</tt> and <tt>abnana</tt>.
</p>
</dd>
<dt>3.</dt>
<dd><p>A character missing in the target string, as with the pattern <tt>road</tt> and
target string <tt>rod</tt>.
</p>
</dd>
<dt>4.</dt>
<dd><p>An extra character appearing in the target string, as with <tt>stove</tt>
and <tt>strove</tt>.
</p>
</dd>
</dl>

<p>Thus, the pattern <tt>(#a3</tt><tt>)abcd</tt> matches <tt>dcba</tt>, with the
errors occurring by using the first rule twice and the second once,
grouping the string as <tt>[d][cb][a]</tt> and <tt>[a][bc][d]</tt>.
</p>
<p>Non-literal parts of the pattern must match exactly, including characters
in character ranges: hence <tt>(#a1</tt><tt>)???</tt>  matches strings of
length four, by applying rule 4 to an empty part of the pattern, but not
strings of length two, since all the <tt>?</tt> must match.  Other characters
which must match exactly are initial dots in filenames (unless the
<tt>GLOB_DOTS</tt> option is set), and all slashes in filenames, so that
<tt>a/bc</tt> is two errors from <tt>ab/c</tt> (the slash cannot be transposed with
another character).  Similarly, errors are counted separately for
non-contiguous strings in the pattern, so that <tt>(ab|cd</tt><tt>)ef</tt>
is two errors from <tt>aebf</tt>.
</p>
<p>When using exclusion via the <tt>~</tt> operator, approximate matching is
treated entirely separately for the excluded part and must be activated
separately.  Thus, <tt>(#a1</tt><tt>)README~READ_ME</tt> matches
<tt>READ.ME</tt> but not <tt>READ_ME</tt>, as the trailing <tt>READ_ME</tt> is matched
without approximation.  However,
<tt>(#a1</tt><tt>)README~(#a1</tt><tt>)READ_ME</tt>
does not match any pattern of the form <tt>READ</tt><var>?</var><tt>ME</tt> as all
such forms are now excluded.
</p>
<p>Apart from exclusions, there is only one overall error count; however, the
maximum errors allowed may be altered locally, and this can be delimited by
grouping.  For example,
<tt>(#a1</tt><tt>)cat</tt><tt>((#a0</tt><tt>)dog</tt><tt>)fox</tt>
allows one error in total, which may not occur in the <tt>dog</tt> section, and
the pattern
<tt>(#a1</tt><tt>)cat</tt><tt>(#a0</tt><tt>)dog</tt><tt>(#a1</tt><tt>)fox</tt>
is equivalent.  Note that the point at which an error is first found is the
crucial one for establishing whether to use approximation; for example,
<tt>(#a1)abc(#a0)xyz</tt> will not match <tt>abcdxyz</tt>, because the
error occurs at the &lsquo;<tt>x</tt>&rsquo;, where approximation is turned off.
</p>
<p>Entire path segments may be matched approximately, so that
&lsquo;<tt>(#a1)/foo/d/is/available/at/the/bar</tt>&rsquo; allows one error in any path
segment.  This is much less efficient than without the <tt>(#a1)</tt>, however,
since every directory in the path must be scanned for a possible
approximate match.  It is best to place the <tt>(#a1)</tt> after any path
segments which are known to be correct.
</p>

<hr>
<a name="Recursive-Globbing"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Approximate-Matching" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Generation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Glob-Qualifiers" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.8.6 Recursive Globbing</h3>
<p>A pathname component of the form &lsquo;<tt>(</tt><var>foo</var><tt>/)#</tt>&rsquo;
matches a path consisting of zero or more directories
matching the pattern <var>foo</var>.
</p>
<p>As a shorthand, &lsquo;<tt>**/</tt>&rsquo; is equivalent to &lsquo;<tt>(*/)#</tt>&rsquo;; note that this
therefore matches files in the current directory as well as
subdirectories.
Thus:
</p>
<div class="example">
<pre class="example">ls (*/)#bar
</pre></div>

<p>or
</p>
<div class="example">
<pre class="example">ls **/bar
</pre></div>

<p>does a recursive directory search for files named &lsquo;<tt>bar</tt>&rsquo; (potentially
including the file &lsquo;<tt>bar</tt>&rsquo; in the current directory).  This form does not
follow symbolic links; the alternative form &lsquo;<tt>***/</tt>&rsquo; does, but is
otherwise identical.  Neither of these can be combined with other forms of
globbing within the same path segment; in that case, the &lsquo;<tt>*</tt>&rsquo;
operators revert to their usual effect.
</p>
<p>Even shorter forms are available when the option <tt>GLOB_STAR_SHORT</tt> is
set.  In that case if no <tt>/</tt> immediately follows a <tt>**</tt> or <tt>***</tt>
they are treated as if both a <tt>/</tt> plus a further <tt>*</tt> are present.
Hence:
</p>
<div class="example">
<pre class="example">setopt GLOBSTARSHORT
ls **.c
</pre></div>

<p>is equivalent to
</p>
<div class="example">
<pre class="example">ls **/*.c
</pre></div>

<hr>
<a name="Glob-Qualifiers"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Recursive-Globbing" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filename-Generation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">14.8.7 Glob Qualifiers</h3>
<a name="index-globbing_002c-qualifiers"></a>
<a name="index-qualifiers_002c-globbing"></a>
<p>Patterns used for filename generation may end in a
list of qualifiers enclosed in parentheses.
The qualifiers specify which filenames that otherwise match the given pattern
will be inserted in the argument list.
</p>
<a name="index-BARE_005fGLOB_005fQUAL_002c-use-of"></a>
<p>If the option <tt>BARE_GLOB_QUAL</tt> is set, then a trailing set of parentheses
containing no &lsquo;<tt>|</tt>&rsquo; or &lsquo;<tt>(</tt>&rsquo; characters (or &lsquo;<tt>~</tt>&rsquo; if it is special)
is taken as a set of
glob qualifiers.  A glob subexpression that would normally be taken as glob
qualifiers, for example &lsquo;<tt>(^x)</tt>&rsquo;, can be forced to be treated as part of
the glob pattern by doubling the parentheses, in this case producing
&lsquo;<tt>((^x))</tt>&rsquo;.
</p>
<p>If the option <tt>EXTENDED_GLOB</tt> is set, a different syntax for glob
qualifiers is available, namely &lsquo;<tt>(#q</tt><var>x</var><tt>)</tt>&rsquo;
where <var>x</var> is any of the same
glob qualifiers used in the other format.  The qualifiers must still appear
at the end of the pattern.  However, with this syntax multiple glob
qualifiers may be chained together.  They are treated as a logical AND of
the individual sets of flags.  Also, as the syntax is unambiguous, the
expression will be treated as glob qualifiers just as long any parentheses
contained within it are balanced; appearance of &lsquo;<tt>|</tt>&rsquo;, &lsquo;<tt>(</tt>&rsquo; or
&lsquo;<tt>~</tt>&rsquo; does not negate the effect.  Note that qualifiers will be
recognised in this form even if a bare glob qualifier exists at the end of
the pattern, for example &lsquo;<tt>*(#q*)(.)</tt>&rsquo; will recognise executable regular
files if both options are set; however, mixed syntax should probably be
avoided for the sake of clarity.  Note that within conditions using the
&lsquo;<tt>[[</tt>&rsquo; form the presence of a parenthesised expression
<tt>(#q</tt><var>...</var><tt>)</tt> at the end of a string indicates that globbing
should be performed; the expression may include glob qualifiers, but
it is also valid if it is simply <tt>(#q)</tt>.  This does
not apply to the right hand side of pattern match operators as the
syntax already has special significance.
</p>
<p>A qualifier may be any one of the following:
</p>
<dl compact="compact">
<dt><tt>/</tt></dt>
<dd><p>directories
</p>
</dd>
<dt><tt>F</tt></dt>
<dd><p>&lsquo;full&rsquo; (i.e. non-empty) directories.  Note that the
opposite sense <tt>(^F</tt><tt>)</tt> expands to empty directories
and all non-directories.  Use <tt>(/^F</tt><tt>)</tt> for
empty directories.
</p>
</dd>
<dt><tt>.</tt></dt>
<dd><p>plain files
</p>
</dd>
<dt><tt>@</tt></dt>
<dd><p>symbolic links
</p>
</dd>
<dt><tt>=</tt></dt>
<dd><p>sockets
</p>
</dd>
<dt><tt>p</tt></dt>
<dd><p>named pipes (FIFOs)
</p>
</dd>
<dt><tt>*</tt></dt>
<dd><p>executable plain files (0100 or 0010 or 0001)
</p>
</dd>
<dt><tt>%</tt></dt>
<dd><p>device files (character or block special)
</p>
</dd>
<dt><tt>%b</tt></dt>
<dd><p>block special files
</p>
</dd>
<dt><tt>%c</tt></dt>
<dd><p>character special files
</p>
</dd>
<dt><tt>r</tt></dt>
<dd><p>owner-readable files (0400)
</p>
</dd>
<dt><tt>w</tt></dt>
<dd><p>owner-writable files (0200)
</p>
</dd>
<dt><tt>x</tt></dt>
<dd><p>owner-executable files (0100)
</p>
</dd>
<dt><tt>A</tt></dt>
<dd><p>group-readable files (0040)
</p>
</dd>
<dt><tt>I</tt></dt>
<dd><p>group-writable files (0020)
</p>
</dd>
<dt><tt>E</tt></dt>
<dd><p>group-executable files (0010)
</p>
</dd>
<dt><tt>R</tt></dt>
<dd><p>world-readable files (0004)
</p>
</dd>
<dt><tt>W</tt></dt>
<dd><p>world-writable files (0002)
</p>
</dd>
<dt><tt>X</tt></dt>
<dd><p>world-executable files (0001)
</p>
</dd>
<dt><tt>s</tt></dt>
<dd><p>setuid files (04000)
</p>
</dd>
<dt><tt>S</tt></dt>
<dd><p>setgid files (02000)
</p>
</dd>
<dt><tt>t</tt></dt>
<dd><p>files with the sticky bit (01000)
</p>
</dd>
<dt><tt>f</tt><var>spec</var></dt>
<dd><p>files with access rights matching <var>spec</var>. This <var>spec</var> may be a
octal number optionally preceded by a &lsquo;<tt>=</tt>&rsquo;, a &lsquo;<tt>+</tt>&rsquo;, or a
&lsquo;<tt>-</tt>&rsquo;. If none of these characters is given, the behavior is the
same as for &lsquo;<tt>=</tt>&rsquo;. The octal number describes the mode bits to be
expected, if combined with a &lsquo;<tt>=</tt>&rsquo;, the value given must match the
file-modes exactly, with a &lsquo;<tt>+</tt>&rsquo;, at least the bits in the
given number must be set in the file-modes, and with a &lsquo;<tt>-</tt>&rsquo;, the
bits in the number must not be set. Giving a &lsquo;<tt>?</tt>&rsquo; instead of a
octal digit anywhere in the number ensures that the corresponding bits 
in the file-modes are not checked, this is only useful in combination
with &lsquo;<tt>=</tt>&rsquo;.
</p>
<p>If the qualifier &lsquo;<tt>f</tt>&rsquo; is followed by any other character anything
up to the next matching character (&lsquo;<tt>[</tt>&rsquo;, &lsquo;<tt>{</tt>&rsquo;, and &lsquo;<tt>&lt;</tt>&rsquo; match 
&lsquo;<tt>]</tt>&rsquo;, &lsquo;<tt>}</tt>&rsquo;, and &lsquo;<tt>&gt;</tt>&rsquo; respectively, any other character
matches itself) is taken as a list of comma-separated
<var>sub-spec</var>s. Each <var>sub-spec</var> may be either an octal number as
described above or a list of any of the characters &lsquo;<tt>u</tt>&rsquo;, &lsquo;<tt>g</tt>&rsquo;,
&lsquo;<tt>o</tt>&rsquo;, and &lsquo;<tt>a</tt>&rsquo;, followed by a &lsquo;<tt>=</tt>&rsquo;, a &lsquo;<tt>+</tt>&rsquo;, or a
&lsquo;<tt>-</tt>&rsquo;, followed by a list of any of the characters &lsquo;<tt>r</tt>&rsquo;, &lsquo;<tt>w</tt>&rsquo;, 
&lsquo;<tt>x</tt>&rsquo;, &lsquo;<tt>s</tt>&rsquo;, and &lsquo;<tt>t</tt>&rsquo;, or an octal digit. The first list of
characters specify which access rights are to be checked. If a &lsquo;<tt>u</tt>&rsquo;
is given, those for the owner of the file are used, if a &lsquo;<tt>g</tt>&rsquo; is
given, those of the group are checked, a &lsquo;<tt>o</tt>&rsquo; means to test those
of other users, and the &lsquo;<tt>a</tt>&rsquo; says to test all three groups. The
&lsquo;<tt>=</tt>&rsquo;, &lsquo;<tt>+</tt>&rsquo;, and &lsquo;<tt>-</tt>&rsquo; again says how the modes are to be
checked and have the same meaning as described for the first form
above. The second list of characters finally says which access rights
are to be expected: &lsquo;<tt>r</tt>&rsquo; for read access, &lsquo;<tt>w</tt>&rsquo; for write access, 
&lsquo;<tt>x</tt>&rsquo; for the right to execute the file (or to search a directory),
&lsquo;<tt>s</tt>&rsquo; for the setuid and setgid bits, and &lsquo;<tt>t</tt>&rsquo; for the sticky
bit.
</p>
<p>Thus, &lsquo;<tt>*(f70?)</tt>&rsquo; gives the files for which the owner has read,
write, and execute permission, and for which other group members have
no rights, independent of the permissions for other users. The pattern
&lsquo;<tt>*(f-100)</tt>&rsquo; gives all files for which the owner does not have
execute permission, and &lsquo;<tt>*(f:gu+w,o-rx:)</tt>&rsquo; gives the files for which 
the owner and the other members of the group have at least write
permission, and for which other users don&rsquo;t have read or execute
permission.
</p>
</dd>
<dt><tt>e</tt><var>string</var></dt>
<dt><tt>+</tt><var>cmd</var></dt>
<dd><p>The <var>string</var> will be executed as shell code.  The filename will be
included in the list if and only if the code returns a zero status (usually
the status of the last command).
</p>
<p>In the first form, the first character after the &lsquo;<tt>e</tt>&rsquo;
will be used as a separator and anything up to the next matching separator
will be taken  as the <var>string</var>; &lsquo;<tt>[</tt>&rsquo;, &lsquo;<tt>{</tt>&rsquo;, and &lsquo;<tt>&lt;</tt>&rsquo; match
&lsquo;<tt>]</tt>&rsquo;, &lsquo;<tt>}</tt>&rsquo;, and &lsquo;<tt>&gt;</tt>&rsquo;, respectively, while any other character
matches itself. Note that expansions must be quoted in the <var>string</var>
to prevent them from being expanded before globbing is done.
<var>string</var> is then executed as shell code.  The string <tt>globqual</tt>
is appended to the array <tt>zsh_eval_context</tt> the duration of
execution.
</p>
<a name="index-REPLY_002c-use-of-1"></a>
<a name="index-reply_002c-use-of"></a>
<p>During the execution of <var>string</var> the filename currently being tested is
available in the parameter <tt>REPLY</tt>; the parameter may be altered to
a string to be inserted into the list instead of the original
filename.  In addition, the parameter <tt>reply</tt> may be set to an array or a
string, which overrides the value of <tt>REPLY</tt>.  If set to an array, the
latter is inserted into the command line word by word.
</p>
<p>For example, suppose a directory contains a single file &lsquo;<tt>lonely</tt>&rsquo;.  Then
the expression &lsquo;<tt>*(e:'reply=(${REPLY}{1,2})':)</tt>&rsquo; will cause the words
&lsquo;<tt>lonely1</tt>&rsquo; and &lsquo;<tt>lonely2</tt>&rsquo; to be inserted into the command line.  Note
the quoting of <var>string</var>.
</p>
<p>The form <tt>+</tt><var>cmd</var> has the same effect, but no delimiters appear
around <var>cmd</var>.  Instead, <var>cmd</var> is taken as the longest sequence of
characters following the <tt>+</tt> that are alphanumeric or underscore.
Typically <var>cmd</var> will be the name of a shell function that contains the
appropriate test.  For example,
</p>
<div class="example">
<pre class="example">nt() { [[ $REPLY -nt $NTREF ]] }
NTREF=reffile
ls -l *(+nt)
</pre></div>

<p>lists all files in the directory that have been modified more recently than
<tt>reffile</tt>.
</p>
</dd>
<dt><tt>d</tt><var>dev</var></dt>
<dd><p>files on the device <var>dev</var>
</p>
</dd>
<dt><tt>l</tt>[<tt>-</tt>|<tt>+</tt>]<var>ct</var></dt>
<dd><p>files having a link count less than <var>ct</var> (<tt>-</tt>), greater than
<var>ct</var> (<tt>+</tt>), or equal to <var>ct</var>
</p>
</dd>
<dt><tt>U</tt></dt>
<dd><p>files owned by the effective user ID
</p>
</dd>
<dt><tt>G</tt></dt>
<dd><p>files owned by the effective group ID
</p>
</dd>
<dt><tt>u</tt><var>id</var></dt>
<dd><p>files owned by user ID <var>id</var> if that is a number.  Otherwise,
<var>id</var> specifies a user name: the
character after the &lsquo;<tt>u</tt>&rsquo; will be taken as a separator and the string
between it and the next matching separator will be taken as a user name.
The starting separators &lsquo;<tt>[</tt>&rsquo;, &lsquo;<tt>{</tt>&rsquo;, and &lsquo;<tt>&lt;</tt>&rsquo;
match the final separators &lsquo;<tt>]</tt>&rsquo;, &lsquo;<tt>}</tt>&rsquo;, and &lsquo;<tt>&gt;</tt>&rsquo;, respectively;
any other character matches itself.  The selected files are those
owned by this user.  For example, &lsquo;<tt>u:foo:</tt>&rsquo; or &lsquo;<tt>u[foo]</tt>&rsquo; selects
files owned by user &lsquo;<tt>foo</tt>&rsquo;.
</p>
</dd>
<dt><tt>g</tt><var>id</var></dt>
<dd><p>like <tt>u</tt><var>id</var> but with group IDs or names
</p>
</dd>
<dt><tt>a</tt>[<tt>Mwhms</tt>][<tt>-</tt>|<tt>+</tt>]<var>n</var></dt>
<dd><p>files accessed exactly <var>n</var> days ago.  Files accessed within the last
<var>n</var> days are selected using a negative value for <var>n</var> (<tt>-</tt><var>n</var>).
Files accessed more than <var>n</var> days ago are selected by a positive <var>n</var>
value (<tt>+</tt><var>n</var>).  Optional unit specifiers &lsquo;<tt>M</tt>&rsquo;, &lsquo;<tt>w</tt>&rsquo;,
&lsquo;<tt>h</tt>&rsquo;, &lsquo;<tt>m</tt>&rsquo; or &lsquo;<tt>s</tt>&rsquo; (e.g. &lsquo;<tt>ah5</tt>&rsquo;) cause the check to be
performed with months (of 30 days), weeks, hours, minutes or seconds
instead of days, respectively.  An explicit &lsquo;<tt>d</tt>&rsquo; for days is also
allowed.
</p>
<p>Any fractional part of the difference between the access time and the
current part in the appropriate units is ignored in the comparison.  For
instance, &lsquo;<tt>echo *(ah-5)</tt>&rsquo; would echo files accessed within the last
five hours, while &lsquo;<tt>echo *(ah+5)</tt>&rsquo; would echo files accessed at least
six hours ago, as times strictly between five and six hours are treated
as five hours.
</p>
</dd>
<dt><tt>m</tt>[<tt>Mwhms</tt>][<tt>-</tt>|<tt>+</tt>]<var>n</var></dt>
<dd><p>like the file access qualifier, except that it uses the file modification
time.
</p>
</dd>
<dt><tt>c</tt>[<tt>Mwhms</tt>][<tt>-</tt>|<tt>+</tt>]<var>n</var></dt>
<dd><p>like the file access qualifier, except that it uses the file inode change
time.
</p>
</dd>
<dt><tt>L</tt>[<tt>+</tt>|<tt>-</tt>]<var>n</var></dt>
<dd><p>files less than <var>n</var> bytes (<tt>-</tt>), more than <var>n</var> bytes (<tt>+</tt>), or
exactly <var>n</var> bytes in length.
</p>
<p>If this flag is directly followed by a <em>size specifier</em> &lsquo;<tt>k</tt>&rsquo; (&lsquo;<tt>K</tt>&rsquo;),
&lsquo;<tt>m</tt>&rsquo; (&lsquo;<tt>M</tt>&rsquo;), or &lsquo;<tt>p</tt>&rsquo; (&lsquo;<tt>P</tt>&rsquo;) (e.g. &lsquo;<tt>Lk-50</tt>&rsquo;) the check is
performed with kilobytes, megabytes, or blocks (of 512 bytes) instead.
(On some systems additional specifiers are available for gigabytes,
&lsquo;<tt>g</tt>&rsquo; or &lsquo;<tt>G</tt>&rsquo;, and terabytes, &lsquo;<tt>t</tt>&rsquo; or &lsquo;<tt>T</tt>&rsquo;.) If a size specifier
is used a file is regarded as &quot;exactly&quot; the size if the file size rounded up
to the next unit is equal to the test size.  Hence &lsquo;<tt>*(Lm1)</tt>&rsquo;
matches files from 1 byte up to 1 Megabyte inclusive.  Note also that
the set of files &quot;less than&quot; the test size only includes files that would
not match the equality test; hence &lsquo;<tt>*(Lm-1)</tt>&rsquo; only matches
files of zero size.
</p>
</dd>
<dt><tt>^</tt></dt>
<dd><p>negates all qualifiers following it
</p>
</dd>
<dt><tt>-</tt></dt>
<dd><p>toggles between making the qualifiers work on symbolic links (the
default) and the files they point to
</p>
</dd>
<dt><tt>M</tt></dt>
<dd><p>sets the <tt>MARK_DIRS</tt> option for the current pattern
<a name="index-MARK_005fDIRS_002c-setting-in-pattern"></a>
</p>
</dd>
<dt><tt>T</tt></dt>
<dd><p>appends a trailing qualifier mark to the filenames, analogous to the
<tt>LIST_TYPES</tt> option, for the current pattern (overrides <tt>M</tt>)
</p>
</dd>
<dt><tt>N</tt></dt>
<dd><p>sets the <tt>NULL_GLOB</tt> option for the current pattern
<a name="index-NULL_005fGLOB_002c-setting-in-pattern"></a>
</p>
</dd>
<dt><tt>D</tt></dt>
<dd><p>sets the <tt>GLOB_DOTS</tt> option for the current pattern
<a name="index-GLOB_005fDOTS_002c-setting-in-pattern"></a>
</p>
</dd>
<dt><tt>n</tt></dt>
<dd><p>sets the <tt>NUMERIC_GLOB_SORT</tt> option for the current pattern
<a name="index-NUMERIC_005fGLOB_005fSORT_002c-setting-in-pattern"></a>
</p>
</dd>
<dt><tt>Y</tt><var>n</var></dt>
<dd><p>enables short-circuit mode: the pattern will expand to at most <var>n</var>
filenames.  If more than <var>n</var> matches exist, only the first <var>n</var>
matches in directory traversal order will be considered.
</p>
<p>Implies <tt>oN</tt> when no <tt>o</tt><var>c</var> qualifier is used.
</p>
</dd>
<dt><tt>o</tt><var>c</var></dt>
<dd><p>specifies how the names of the files should be sorted. If <var>c</var> is
<tt>n</tt> they are sorted by name; if it is <tt>L</tt> they
are sorted depending on the size (length) of the files; if <tt>l</tt>
they are sorted by the number of links; if <tt>a</tt>, <tt>m</tt>, or <tt>c</tt>
they are sorted by the time of the last access, modification, or
inode change respectively; if <tt>d</tt>, files in subdirectories appear before
those in the current directory at each level of the search &mdash; this is best
combined with other criteria, for example &lsquo;<tt>odon</tt>&rsquo; to sort on names for
files within the same directory; if <tt>N</tt>, no sorting is performed.
Note that <tt>a</tt>, <tt>m</tt>, and <tt>c</tt> compare
the age against the current time, hence the first name in the list is the
youngest file. Also note that the modifiers <tt>^</tt> and <tt>-</tt> are used,
so &lsquo;<tt>*(^-oL)</tt>&rsquo; gives a list of all files sorted by file size in descending
order, following any symbolic links.  Unless <tt>oN</tt> is used, multiple order
specifiers may occur to resolve ties.
</p>
<p>The default sorting is <tt>n</tt> (by name) unless the <tt>Y</tt> glob qualifier is used,
in which case it is <tt>N</tt> (unsorted).
</p>
<p><tt>oe</tt> and <tt>o+</tt> are special cases; they are each followed by shell code,
delimited as for the <tt>e</tt> glob qualifier and the <tt>+</tt> glob qualifier
respectively (see above).  The code is executed for each matched file with
the parameter <tt>REPLY</tt> set to the name of the file on entry and
<tt>globsort</tt> appended to <tt>zsh_eval_context</tt>.  The code
should modify the parameter <tt>REPLY</tt> in some fashion.  On return, the
value of the parameter is used instead of the file name as the string on
which to sort.  Unlike other sort operators, <tt>oe</tt> and <tt>o+</tt> may be
repeated, but note that the maximum number of sort operators of any kind
that may appear in any glob expression is 12.
</p>
</dd>
<dt><tt>O</tt><var>c</var></dt>
<dd><p>like &lsquo;<tt>o</tt>&rsquo;, but sorts in descending order; i.e. &lsquo;<tt>*(^oc)</tt>&rsquo; is the
same as &lsquo;<tt>*(Oc)</tt>&rsquo; and &lsquo;<tt>*(^Oc)</tt>&rsquo; is the same as &lsquo;<tt>*(oc)</tt>&rsquo;; &lsquo;<tt>Od</tt>&rsquo;
puts files in the current directory before those in subdirectories at each
level of the search.
</p>
</dd>
<dt><tt>[</tt><var>beg</var>[<tt>,</tt><var>end</var>]<tt>]</tt></dt>
<dd><p>specifies which of the matched filenames should be included in the
returned list. The syntax is the same as for array
subscripts. <var>beg</var> and the optional <var>end</var> may be mathematical
expressions. As in parameter subscripting they may be negative to make 
them count from the last match backward. E.g.: &lsquo;<tt>*(-OL[1,3])</tt>&rsquo;
gives a list of the names of the three largest files.
</p>
</dd>
<dt><tt>P</tt><var>string</var></dt>
<dd><p>The <var>string</var> will be prepended to each glob match as a separate
word.  <var>string</var> is delimited in the same way as arguments to the
<tt>e</tt> glob qualifier described above.  The qualifier can be repeated;
the words are prepended separately so that the resulting command
line contains the words in the same order they were given in the
list of glob qualifiers.
</p>
<p>A typical use for this is to prepend an option before all occurrences
of a file name; for example, the pattern &lsquo;<tt>*(P:-f:)</tt>&rsquo; produces the
command line arguments &lsquo;<tt>-f</tt> <var>file1</var> <tt>-f</tt> <var>file2</var> ...&rsquo;
</p>
<p>If the modifier <tt>^</tt> is active, then <var>string</var> will be appended
instead of prepended.  Prepending and appending is done independently
so both can be used on the same glob expression; for example by writing
&lsquo;<tt>*(P:foo:^P:bar:^P:baz:)</tt>&rsquo; which produces the command line arguments
&lsquo;<tt>foo</tt> <tt>baz</tt> <var>file1</var> <tt>bar</tt> ...&rsquo;
</p>
</dd>
</dl>

<p>More than one of these lists can be combined, separated by commas. The
whole list matches if at least one of the sublists matches (they are
&lsquo;or&rsquo;ed, the qualifiers in the sublists are &lsquo;and&rsquo;ed).  Some qualifiers,
however, affect all matches generated, independent of the sublist in
which they are given.  These are the qualifiers &lsquo;<tt>M</tt>&rsquo;, &lsquo;<tt>T</tt>&rsquo;,
&lsquo;<tt>N</tt>&rsquo;, &lsquo;<tt>D</tt>&rsquo;, &lsquo;<tt>n</tt>&rsquo;, &lsquo;<tt>o</tt>&rsquo;, &lsquo;<tt>O</tt>&rsquo; and the subscripts given
in brackets (&lsquo;<tt>[</tt><var>...</var><tt>]</tt>&rsquo;).
</p>
<p>If a &lsquo;<tt>:</tt>&rsquo; appears in a qualifier list, the remainder of the expression in
parenthesis is interpreted as a modifier (see <a href="#Modifiers">Modifiers</a>
in <a href="#History-Expansion">History Expansion</a>).  Each modifier must be introduced by a
separate &lsquo;<tt>:</tt>&rsquo;.  Note also that the result after modification does not
have to be an existing file.  The name of any existing file can be followed
by a modifier of the form &lsquo;<tt>(:</tt><var>...</var><tt>)</tt>&rsquo;
even if no actual filename generation
is performed, although note that the presence of the parentheses
causes the entire expression to be subjected to any global pattern matching
options such as <tt>NULL_GLOB</tt>. Thus:
</p>
<div class="example">
<pre class="example">ls *(-/)
</pre></div>

<p>lists all directories and symbolic links that point to directories,
and
</p>
<div class="example">
<pre class="example">ls *(-@)
</pre></div>

<p>lists all broken symbolic links, and
</p>
<div class="example">
<pre class="example">ls *(%W)
</pre></div>

<p>lists all world-writable device files in the current directory, and
</p>
<div class="example">
<pre class="example">ls *(W,X)
</pre></div>

<p>lists all files in the current directory that are
world-writable or world-executable, and
</p>
<div class="example">
<pre class="example">echo /tmp/foo*(u0^@:t)
</pre></div>

<p>outputs the basename of all root-owned files beginning with the string
&lsquo;<tt>foo</tt>&rsquo; in <tt>/tmp</tt>, ignoring symlinks, and
</p>
<div class="example">
<pre class="example">ls *.*~(lex|parse).[ch](^D^l1)
</pre></div>

<p>lists all files having a link count of one whose names contain a dot
(but not those starting with a dot, since <tt>GLOB_DOTS</tt> is explicitly
switched off) except for <tt>lex.c</tt>, <tt>lex.h</tt>, <tt>parse.c</tt> and <tt>parse.h</tt>.
</p>
<div class="example">
<pre class="example">print b*.pro(#q:s/pro/shmo/)(#q.:s/builtin/shmiltin/)
</pre></div>

<p>demonstrates how colon modifiers and other qualifiers may be chained
together.  The ordinary qualifier &lsquo;<tt>.</tt>&rsquo; is applied first, then the colon
modifiers in order from left to right.  So if <tt>EXTENDED_GLOB</tt> is set and
the base pattern matches the regular file <tt>builtin.pro</tt>, the shell will
print &lsquo;<tt>shmiltin.shmo</tt>&rsquo;.
</p><hr>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expansion" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="Parameters.html#Parameters" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="zsh_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="Concept-Index.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="zsh_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p><font size="-1">
  This document was generated on <em>September 21, 2017</em> using <a href="http://www.gnu.org/software/texinfo/"><em>texi2any</em></a>.
</font></p>

<font size="-1">Zsh version 5.4.2, released on August 27, 2017.</font>
</body>
</html>
